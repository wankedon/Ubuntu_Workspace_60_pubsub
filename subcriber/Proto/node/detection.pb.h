// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node/detection.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_2fdetection_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_2fdetection_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
#include "node/spectrum.pb.h"
#include "node/node.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_2fdetection_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_2fdetection_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_node_2fdetection_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_node_2fdetection_2eproto_metadata_getter(int index);
namespace zb {
namespace dcts {
namespace node {
namespace detection {
class AdaptiveThresholdParam;
struct AdaptiveThresholdParamDefaultTypeInternal;
extern AdaptiveThresholdParamDefaultTypeInternal _AdaptiveThresholdParam_default_instance_;
class DetailKeeping;
struct DetailKeepingDefaultTypeInternal;
extern DetailKeepingDefaultTypeInternal _DetailKeeping_default_instance_;
class DetailKeepingRequest;
struct DetailKeepingRequestDefaultTypeInternal;
extern DetailKeepingRequestDefaultTypeInternal _DetailKeepingRequest_default_instance_;
class DetectionOption;
struct DetectionOptionDefaultTypeInternal;
extern DetectionOptionDefaultTypeInternal _DetectionOption_default_instance_;
class DetectionParam;
struct DetectionParamDefaultTypeInternal;
extern DetectionParamDefaultTypeInternal _DetectionParam_default_instance_;
class DetectionRequest;
struct DetectionRequestDefaultTypeInternal;
extern DetectionRequestDefaultTypeInternal _DetectionRequest_default_instance_;
class EnergyDetectionParam;
struct EnergyDetectionParamDefaultTypeInternal;
extern EnergyDetectionParamDefaultTypeInternal _EnergyDetectionParam_default_instance_;
class HistoryThresholdParam;
struct HistoryThresholdParamDefaultTypeInternal;
extern HistoryThresholdParamDefaultTypeInternal _HistoryThresholdParam_default_instance_;
class HitsSegmentation;
struct HitsSegmentationDefaultTypeInternal;
extern HitsSegmentationDefaultTypeInternal _HitsSegmentation_default_instance_;
class MergeParam;
struct MergeParamDefaultTypeInternal;
extern MergeParamDefaultTypeInternal _MergeParam_default_instance_;
class SegmentationParam;
struct SegmentationParamDefaultTypeInternal;
extern SegmentationParamDefaultTypeInternal _SegmentationParam_default_instance_;
class SignalFeature;
struct SignalFeatureDefaultTypeInternal;
extern SignalFeatureDefaultTypeInternal _SignalFeature_default_instance_;
class SignalList;
struct SignalListDefaultTypeInternal;
extern SignalListDefaultTypeInternal _SignalList_default_instance_;
class SignalSegment;
struct SignalSegmentDefaultTypeInternal;
extern SignalSegmentDefaultTypeInternal _SignalSegment_default_instance_;
class SpectrumIntersection;
struct SpectrumIntersectionDefaultTypeInternal;
extern SpectrumIntersectionDefaultTypeInternal _SpectrumIntersection_default_instance_;
class ThresholdRefLine;
struct ThresholdRefLineDefaultTypeInternal;
extern ThresholdRefLineDefaultTypeInternal _ThresholdRefLine_default_instance_;
class ThresholdSector;
struct ThresholdSectorDefaultTypeInternal;
extern ThresholdSectorDefaultTypeInternal _ThresholdSector_default_instance_;
class UserThresholdParam;
struct UserThresholdParamDefaultTypeInternal;
extern UserThresholdParamDefaultTypeInternal _UserThresholdParam_default_instance_;
}  // namespace detection
}  // namespace node
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::node::detection::AdaptiveThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::AdaptiveThresholdParam>(Arena*);
template<> ::zb::dcts::node::detection::DetailKeeping* Arena::CreateMaybeMessage<::zb::dcts::node::detection::DetailKeeping>(Arena*);
template<> ::zb::dcts::node::detection::DetailKeepingRequest* Arena::CreateMaybeMessage<::zb::dcts::node::detection::DetailKeepingRequest>(Arena*);
template<> ::zb::dcts::node::detection::DetectionOption* Arena::CreateMaybeMessage<::zb::dcts::node::detection::DetectionOption>(Arena*);
template<> ::zb::dcts::node::detection::DetectionParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::DetectionParam>(Arena*);
template<> ::zb::dcts::node::detection::DetectionRequest* Arena::CreateMaybeMessage<::zb::dcts::node::detection::DetectionRequest>(Arena*);
template<> ::zb::dcts::node::detection::EnergyDetectionParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::EnergyDetectionParam>(Arena*);
template<> ::zb::dcts::node::detection::HistoryThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::HistoryThresholdParam>(Arena*);
template<> ::zb::dcts::node::detection::HitsSegmentation* Arena::CreateMaybeMessage<::zb::dcts::node::detection::HitsSegmentation>(Arena*);
template<> ::zb::dcts::node::detection::MergeParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::MergeParam>(Arena*);
template<> ::zb::dcts::node::detection::SegmentationParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::SegmentationParam>(Arena*);
template<> ::zb::dcts::node::detection::SignalFeature* Arena::CreateMaybeMessage<::zb::dcts::node::detection::SignalFeature>(Arena*);
template<> ::zb::dcts::node::detection::SignalList* Arena::CreateMaybeMessage<::zb::dcts::node::detection::SignalList>(Arena*);
template<> ::zb::dcts::node::detection::SignalSegment* Arena::CreateMaybeMessage<::zb::dcts::node::detection::SignalSegment>(Arena*);
template<> ::zb::dcts::node::detection::SpectrumIntersection* Arena::CreateMaybeMessage<::zb::dcts::node::detection::SpectrumIntersection>(Arena*);
template<> ::zb::dcts::node::detection::ThresholdRefLine* Arena::CreateMaybeMessage<::zb::dcts::node::detection::ThresholdRefLine>(Arena*);
template<> ::zb::dcts::node::detection::ThresholdSector* Arena::CreateMaybeMessage<::zb::dcts::node::detection::ThresholdSector>(Arena*);
template<> ::zb::dcts::node::detection::UserThresholdParam* Arena::CreateMaybeMessage<::zb::dcts::node::detection::UserThresholdParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace node {
namespace detection {

enum AdaptiveThresholdParam_PartitionMode : int {
  AdaptiveThresholdParam_PartitionMode_PM_STANDARD = 0,
  AdaptiveThresholdParam_PartitionMode_PM_AGGRESIVE = 1,
  AdaptiveThresholdParam_PartitionMode_PM_FAST = 2,
  AdaptiveThresholdParam_PartitionMode_AdaptiveThresholdParam_PartitionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AdaptiveThresholdParam_PartitionMode_AdaptiveThresholdParam_PartitionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AdaptiveThresholdParam_PartitionMode_IsValid(int value);
constexpr AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam_PartitionMode_PartitionMode_MIN = AdaptiveThresholdParam_PartitionMode_PM_STANDARD;
constexpr AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX = AdaptiveThresholdParam_PartitionMode_PM_FAST;
constexpr int AdaptiveThresholdParam_PartitionMode_PartitionMode_ARRAYSIZE = AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdaptiveThresholdParam_PartitionMode_descriptor();
template<typename T>
inline const std::string& AdaptiveThresholdParam_PartitionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdaptiveThresholdParam_PartitionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdaptiveThresholdParam_PartitionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdaptiveThresholdParam_PartitionMode_descriptor(), enum_t_value);
}
inline bool AdaptiveThresholdParam_PartitionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AdaptiveThresholdParam_PartitionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdaptiveThresholdParam_PartitionMode>(
    AdaptiveThresholdParam_PartitionMode_descriptor(), name, value);
}
enum EnergyDetectionParam_LogicType : int {
  EnergyDetectionParam_LogicType_LT_AND = 0,
  EnergyDetectionParam_LogicType_LT_OR = 1,
  EnergyDetectionParam_LogicType_EnergyDetectionParam_LogicType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EnergyDetectionParam_LogicType_EnergyDetectionParam_LogicType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EnergyDetectionParam_LogicType_IsValid(int value);
constexpr EnergyDetectionParam_LogicType EnergyDetectionParam_LogicType_LogicType_MIN = EnergyDetectionParam_LogicType_LT_AND;
constexpr EnergyDetectionParam_LogicType EnergyDetectionParam_LogicType_LogicType_MAX = EnergyDetectionParam_LogicType_LT_OR;
constexpr int EnergyDetectionParam_LogicType_LogicType_ARRAYSIZE = EnergyDetectionParam_LogicType_LogicType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EnergyDetectionParam_LogicType_descriptor();
template<typename T>
inline const std::string& EnergyDetectionParam_LogicType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnergyDetectionParam_LogicType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnergyDetectionParam_LogicType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EnergyDetectionParam_LogicType_descriptor(), enum_t_value);
}
inline bool EnergyDetectionParam_LogicType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnergyDetectionParam_LogicType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EnergyDetectionParam_LogicType>(
    EnergyDetectionParam_LogicType_descriptor(), name, value);
}
enum ThresholdType : int {
  HISTORY = 0,
  USER_DEFINE = 1,
  ADAPTIVE = 2,
  ThresholdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdType_IsValid(int value);
constexpr ThresholdType ThresholdType_MIN = HISTORY;
constexpr ThresholdType ThresholdType_MAX = ADAPTIVE;
constexpr int ThresholdType_ARRAYSIZE = ThresholdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdType_descriptor();
template<typename T>
inline const std::string& ThresholdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdType_descriptor(), enum_t_value);
}
inline bool ThresholdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThresholdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdType>(
    ThresholdType_descriptor(), name, value);
}
enum SignalActivity : int {
  ACTIVE = 0,
  INACTIVE = 1,
  DECAYED = 2,
  MERGED = 3,
  UNKNOWN = 4,
  SignalActivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SignalActivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SignalActivity_IsValid(int value);
constexpr SignalActivity SignalActivity_MIN = ACTIVE;
constexpr SignalActivity SignalActivity_MAX = UNKNOWN;
constexpr int SignalActivity_ARRAYSIZE = SignalActivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SignalActivity_descriptor();
template<typename T>
inline const std::string& SignalActivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SignalActivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SignalActivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SignalActivity_descriptor(), enum_t_value);
}
inline bool SignalActivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalActivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SignalActivity>(
    SignalActivity_descriptor(), name, value);
}
enum SegmentationFilterType : int {
  RESERVED = 0,
  OVERLAP = 1,
  HITS = 2,
  WHITE_LIST = 4,
  BLACK_LIST = 8,
  SegmentationFilterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SegmentationFilterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SegmentationFilterType_IsValid(int value);
constexpr SegmentationFilterType SegmentationFilterType_MIN = RESERVED;
constexpr SegmentationFilterType SegmentationFilterType_MAX = BLACK_LIST;
constexpr int SegmentationFilterType_ARRAYSIZE = SegmentationFilterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SegmentationFilterType_descriptor();
template<typename T>
inline const std::string& SegmentationFilterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SegmentationFilterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SegmentationFilterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SegmentationFilterType_descriptor(), enum_t_value);
}
inline bool SegmentationFilterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentationFilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SegmentationFilterType>(
    SegmentationFilterType_descriptor(), name, value);
}
enum MergePolicy : int {
  NO_POLICY = 0,
  SPECTRUM_INTERSECT_POLICY = 1,
  MergePolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MergePolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MergePolicy_IsValid(int value);
constexpr MergePolicy MergePolicy_MIN = NO_POLICY;
constexpr MergePolicy MergePolicy_MAX = SPECTRUM_INTERSECT_POLICY;
constexpr int MergePolicy_ARRAYSIZE = MergePolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MergePolicy_descriptor();
template<typename T>
inline const std::string& MergePolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MergePolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MergePolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MergePolicy_descriptor(), enum_t_value);
}
inline bool MergePolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MergePolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MergePolicy>(
    MergePolicy_descriptor(), name, value);
}
// ===================================================================

class ThresholdSector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.ThresholdSector) */ {
 public:
  inline ThresholdSector() : ThresholdSector(nullptr) {}
  virtual ~ThresholdSector();
  explicit constexpr ThresholdSector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThresholdSector(const ThresholdSector& from);
  ThresholdSector(ThresholdSector&& from) noexcept
    : ThresholdSector() {
    *this = ::std::move(from);
  }

  inline ThresholdSector& operator=(const ThresholdSector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdSector& operator=(ThresholdSector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThresholdSector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThresholdSector* internal_default_instance() {
    return reinterpret_cast<const ThresholdSector*>(
               &_ThresholdSector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ThresholdSector& a, ThresholdSector& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdSector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdSector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThresholdSector* New() const final {
    return CreateMaybeMessage<ThresholdSector>(nullptr);
  }

  ThresholdSector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdSector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThresholdSector& from);
  void MergeFrom(const ThresholdSector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdSector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.ThresholdSector";
  }
  protected:
  explicit ThresholdSector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFreqSpanFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // .zb.dcts.node.spectrum.FrequencySpan freq_span = 1;
  bool has_freq_span() const;
  private:
  bool _internal_has_freq_span() const;
  public:
  void clear_freq_span();
  const ::zb::dcts::node::spectrum::FrequencySpan& freq_span() const;
  ::zb::dcts::node::spectrum::FrequencySpan* release_freq_span();
  ::zb::dcts::node::spectrum::FrequencySpan* mutable_freq_span();
  void set_allocated_freq_span(::zb::dcts::node::spectrum::FrequencySpan* freq_span);
  private:
  const ::zb::dcts::node::spectrum::FrequencySpan& _internal_freq_span() const;
  ::zb::dcts::node::spectrum::FrequencySpan* _internal_mutable_freq_span();
  public:
  void unsafe_arena_set_allocated_freq_span(
      ::zb::dcts::node::spectrum::FrequencySpan* freq_span);
  ::zb::dcts::node::spectrum::FrequencySpan* unsafe_arena_release_freq_span();

  // float level = 2;
  void clear_level();
  float level() const;
  void set_level(float value);
  private:
  float _internal_level() const;
  void _internal_set_level(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.ThresholdSector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::spectrum::FrequencySpan* freq_span_;
  float level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HistoryThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.HistoryThresholdParam) */ {
 public:
  inline HistoryThresholdParam() : HistoryThresholdParam(nullptr) {}
  virtual ~HistoryThresholdParam();
  explicit constexpr HistoryThresholdParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HistoryThresholdParam(const HistoryThresholdParam& from);
  HistoryThresholdParam(HistoryThresholdParam&& from) noexcept
    : HistoryThresholdParam() {
    *this = ::std::move(from);
  }

  inline HistoryThresholdParam& operator=(const HistoryThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline HistoryThresholdParam& operator=(HistoryThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HistoryThresholdParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const HistoryThresholdParam* internal_default_instance() {
    return reinterpret_cast<const HistoryThresholdParam*>(
               &_HistoryThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HistoryThresholdParam& a, HistoryThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(HistoryThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HistoryThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HistoryThresholdParam* New() const final {
    return CreateMaybeMessage<HistoryThresholdParam>(nullptr);
  }

  HistoryThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HistoryThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HistoryThresholdParam& from);
  void MergeFrom(const HistoryThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HistoryThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.HistoryThresholdParam";
  }
  protected:
  explicit HistoryThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpanFieldNumber = 1,
    kMaxLoadCountFieldNumber = 3,
    kOffsetFieldNumber = 4,
  };
  // .zb.dcts.TimeSpan span = 1;
  bool has_span() const;
  private:
  bool _internal_has_span() const;
  public:
  void clear_span();
  const ::zb::dcts::TimeSpan& span() const;
  ::zb::dcts::TimeSpan* release_span();
  ::zb::dcts::TimeSpan* mutable_span();
  void set_allocated_span(::zb::dcts::TimeSpan* span);
  private:
  const ::zb::dcts::TimeSpan& _internal_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_span();
  public:
  void unsafe_arena_set_allocated_span(
      ::zb::dcts::TimeSpan* span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_span();

  // int32 max_load_count = 3;
  void clear_max_load_count();
  ::PROTOBUF_NAMESPACE_ID::int32 max_load_count() const;
  void set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_load_count() const;
  void _internal_set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float offset = 4;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.HistoryThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::TimeSpan* span_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_load_count_;
  float offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class UserThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.UserThresholdParam) */ {
 public:
  inline UserThresholdParam() : UserThresholdParam(nullptr) {}
  virtual ~UserThresholdParam();
  explicit constexpr UserThresholdParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserThresholdParam(const UserThresholdParam& from);
  UserThresholdParam(UserThresholdParam&& from) noexcept
    : UserThresholdParam() {
    *this = ::std::move(from);
  }

  inline UserThresholdParam& operator=(const UserThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserThresholdParam& operator=(UserThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserThresholdParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserThresholdParam* internal_default_instance() {
    return reinterpret_cast<const UserThresholdParam*>(
               &_UserThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserThresholdParam& a, UserThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(UserThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserThresholdParam* New() const final {
    return CreateMaybeMessage<UserThresholdParam>(nullptr);
  }

  UserThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserThresholdParam& from);
  void MergeFrom(const UserThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.UserThresholdParam";
  }
  protected:
  explicit UserThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorsFieldNumber = 1,
  };
  // repeated .zb.dcts.node.detection.ThresholdSector sectors = 1;
  int sectors_size() const;
  private:
  int _internal_sectors_size() const;
  public:
  void clear_sectors();
  ::zb::dcts::node::detection::ThresholdSector* mutable_sectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::ThresholdSector >*
      mutable_sectors();
  private:
  const ::zb::dcts::node::detection::ThresholdSector& _internal_sectors(int index) const;
  ::zb::dcts::node::detection::ThresholdSector* _internal_add_sectors();
  public:
  const ::zb::dcts::node::detection::ThresholdSector& sectors(int index) const;
  ::zb::dcts::node::detection::ThresholdSector* add_sectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::ThresholdSector >&
      sectors() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.UserThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::ThresholdSector > sectors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class AdaptiveThresholdParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.AdaptiveThresholdParam) */ {
 public:
  inline AdaptiveThresholdParam() : AdaptiveThresholdParam(nullptr) {}
  virtual ~AdaptiveThresholdParam();
  explicit constexpr AdaptiveThresholdParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdaptiveThresholdParam(const AdaptiveThresholdParam& from);
  AdaptiveThresholdParam(AdaptiveThresholdParam&& from) noexcept
    : AdaptiveThresholdParam() {
    *this = ::std::move(from);
  }

  inline AdaptiveThresholdParam& operator=(const AdaptiveThresholdParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdaptiveThresholdParam& operator=(AdaptiveThresholdParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdaptiveThresholdParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdaptiveThresholdParam* internal_default_instance() {
    return reinterpret_cast<const AdaptiveThresholdParam*>(
               &_AdaptiveThresholdParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AdaptiveThresholdParam& a, AdaptiveThresholdParam& b) {
    a.Swap(&b);
  }
  inline void Swap(AdaptiveThresholdParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdaptiveThresholdParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdaptiveThresholdParam* New() const final {
    return CreateMaybeMessage<AdaptiveThresholdParam>(nullptr);
  }

  AdaptiveThresholdParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdaptiveThresholdParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdaptiveThresholdParam& from);
  void MergeFrom(const AdaptiveThresholdParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdaptiveThresholdParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.AdaptiveThresholdParam";
  }
  protected:
  explicit AdaptiveThresholdParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef AdaptiveThresholdParam_PartitionMode PartitionMode;
  static constexpr PartitionMode PM_STANDARD =
    AdaptiveThresholdParam_PartitionMode_PM_STANDARD;
  static constexpr PartitionMode PM_AGGRESIVE =
    AdaptiveThresholdParam_PartitionMode_PM_AGGRESIVE;
  static constexpr PartitionMode PM_FAST =
    AdaptiveThresholdParam_PartitionMode_PM_FAST;
  static inline bool PartitionMode_IsValid(int value) {
    return AdaptiveThresholdParam_PartitionMode_IsValid(value);
  }
  static constexpr PartitionMode PartitionMode_MIN =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_MIN;
  static constexpr PartitionMode PartitionMode_MAX =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_MAX;
  static constexpr int PartitionMode_ARRAYSIZE =
    AdaptiveThresholdParam_PartitionMode_PartitionMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PartitionMode_descriptor() {
    return AdaptiveThresholdParam_PartitionMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PartitionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PartitionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PartitionMode_Name.");
    return AdaptiveThresholdParam_PartitionMode_Name(enum_t_value);
  }
  static inline bool PartitionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PartitionMode* value) {
    return AdaptiveThresholdParam_PartitionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAverageCountFieldNumber = 1,
    kPartitionModeFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // int32 average_count = 1;
  void clear_average_count();
  ::PROTOBUF_NAMESPACE_ID::int32 average_count() const;
  void set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_average_count() const;
  void _internal_set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .zb.dcts.node.detection.AdaptiveThresholdParam.PartitionMode partition_mode = 2;
  void clear_partition_mode();
  ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode partition_mode() const;
  void set_partition_mode(::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode value);
  private:
  ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode _internal_partition_mode() const;
  void _internal_set_partition_mode(::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode value);
  public:

  // float offset = 3;
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.AdaptiveThresholdParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 average_count_;
  int partition_mode_;
  float offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class EnergyDetectionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.EnergyDetectionParam) */ {
 public:
  inline EnergyDetectionParam() : EnergyDetectionParam(nullptr) {}
  virtual ~EnergyDetectionParam();
  explicit constexpr EnergyDetectionParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnergyDetectionParam(const EnergyDetectionParam& from);
  EnergyDetectionParam(EnergyDetectionParam&& from) noexcept
    : EnergyDetectionParam() {
    *this = ::std::move(from);
  }

  inline EnergyDetectionParam& operator=(const EnergyDetectionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnergyDetectionParam& operator=(EnergyDetectionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnergyDetectionParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnergyDetectionParam* internal_default_instance() {
    return reinterpret_cast<const EnergyDetectionParam*>(
               &_EnergyDetectionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EnergyDetectionParam& a, EnergyDetectionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(EnergyDetectionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnergyDetectionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnergyDetectionParam* New() const final {
    return CreateMaybeMessage<EnergyDetectionParam>(nullptr);
  }

  EnergyDetectionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnergyDetectionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnergyDetectionParam& from);
  void MergeFrom(const EnergyDetectionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnergyDetectionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.EnergyDetectionParam";
  }
  protected:
  explicit EnergyDetectionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef EnergyDetectionParam_LogicType LogicType;
  static constexpr LogicType LT_AND =
    EnergyDetectionParam_LogicType_LT_AND;
  static constexpr LogicType LT_OR =
    EnergyDetectionParam_LogicType_LT_OR;
  static inline bool LogicType_IsValid(int value) {
    return EnergyDetectionParam_LogicType_IsValid(value);
  }
  static constexpr LogicType LogicType_MIN =
    EnergyDetectionParam_LogicType_LogicType_MIN;
  static constexpr LogicType LogicType_MAX =
    EnergyDetectionParam_LogicType_LogicType_MAX;
  static constexpr int LogicType_ARRAYSIZE =
    EnergyDetectionParam_LogicType_LogicType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LogicType_descriptor() {
    return EnergyDetectionParam_LogicType_descriptor();
  }
  template<typename T>
  static inline const std::string& LogicType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LogicType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LogicType_Name.");
    return EnergyDetectionParam_LogicType_Name(enum_t_value);
  }
  static inline bool LogicType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LogicType* value) {
    return EnergyDetectionParam_LogicType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActiveTypesFieldNumber = 1,
    kHistoryThresholdFieldNumber = 5,
    kUserThresholdFieldNumber = 6,
    kAdaptiveThresholdFieldNumber = 7,
    kLogicFieldNumber = 3,
  };
  // repeated .zb.dcts.node.detection.ThresholdType active_types = 1;
  int active_types_size() const;
  private:
  int _internal_active_types_size() const;
  public:
  void clear_active_types();
  private:
  ::zb::dcts::node::detection::ThresholdType _internal_active_types(int index) const;
  void _internal_add_active_types(::zb::dcts::node::detection::ThresholdType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_active_types();
  public:
  ::zb::dcts::node::detection::ThresholdType active_types(int index) const;
  void set_active_types(int index, ::zb::dcts::node::detection::ThresholdType value);
  void add_active_types(::zb::dcts::node::detection::ThresholdType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& active_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_active_types();

  // .zb.dcts.node.detection.HistoryThresholdParam history_threshold = 5;
  bool has_history_threshold() const;
  private:
  bool _internal_has_history_threshold() const;
  public:
  void clear_history_threshold();
  const ::zb::dcts::node::detection::HistoryThresholdParam& history_threshold() const;
  ::zb::dcts::node::detection::HistoryThresholdParam* release_history_threshold();
  ::zb::dcts::node::detection::HistoryThresholdParam* mutable_history_threshold();
  void set_allocated_history_threshold(::zb::dcts::node::detection::HistoryThresholdParam* history_threshold);
  private:
  const ::zb::dcts::node::detection::HistoryThresholdParam& _internal_history_threshold() const;
  ::zb::dcts::node::detection::HistoryThresholdParam* _internal_mutable_history_threshold();
  public:
  void unsafe_arena_set_allocated_history_threshold(
      ::zb::dcts::node::detection::HistoryThresholdParam* history_threshold);
  ::zb::dcts::node::detection::HistoryThresholdParam* unsafe_arena_release_history_threshold();

  // .zb.dcts.node.detection.UserThresholdParam user_threshold = 6;
  bool has_user_threshold() const;
  private:
  bool _internal_has_user_threshold() const;
  public:
  void clear_user_threshold();
  const ::zb::dcts::node::detection::UserThresholdParam& user_threshold() const;
  ::zb::dcts::node::detection::UserThresholdParam* release_user_threshold();
  ::zb::dcts::node::detection::UserThresholdParam* mutable_user_threshold();
  void set_allocated_user_threshold(::zb::dcts::node::detection::UserThresholdParam* user_threshold);
  private:
  const ::zb::dcts::node::detection::UserThresholdParam& _internal_user_threshold() const;
  ::zb::dcts::node::detection::UserThresholdParam* _internal_mutable_user_threshold();
  public:
  void unsafe_arena_set_allocated_user_threshold(
      ::zb::dcts::node::detection::UserThresholdParam* user_threshold);
  ::zb::dcts::node::detection::UserThresholdParam* unsafe_arena_release_user_threshold();

  // .zb.dcts.node.detection.AdaptiveThresholdParam adaptive_threshold = 7;
  bool has_adaptive_threshold() const;
  private:
  bool _internal_has_adaptive_threshold() const;
  public:
  void clear_adaptive_threshold();
  const ::zb::dcts::node::detection::AdaptiveThresholdParam& adaptive_threshold() const;
  ::zb::dcts::node::detection::AdaptiveThresholdParam* release_adaptive_threshold();
  ::zb::dcts::node::detection::AdaptiveThresholdParam* mutable_adaptive_threshold();
  void set_allocated_adaptive_threshold(::zb::dcts::node::detection::AdaptiveThresholdParam* adaptive_threshold);
  private:
  const ::zb::dcts::node::detection::AdaptiveThresholdParam& _internal_adaptive_threshold() const;
  ::zb::dcts::node::detection::AdaptiveThresholdParam* _internal_mutable_adaptive_threshold();
  public:
  void unsafe_arena_set_allocated_adaptive_threshold(
      ::zb::dcts::node::detection::AdaptiveThresholdParam* adaptive_threshold);
  ::zb::dcts::node::detection::AdaptiveThresholdParam* unsafe_arena_release_adaptive_threshold();

  // .zb.dcts.node.detection.EnergyDetectionParam.LogicType logic = 3;
  void clear_logic();
  ::zb::dcts::node::detection::EnergyDetectionParam_LogicType logic() const;
  void set_logic(::zb::dcts::node::detection::EnergyDetectionParam_LogicType value);
  private:
  ::zb::dcts::node::detection::EnergyDetectionParam_LogicType _internal_logic() const;
  void _internal_set_logic(::zb::dcts::node::detection::EnergyDetectionParam_LogicType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.EnergyDetectionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> active_types_;
  mutable std::atomic<int> _active_types_cached_byte_size_;
  ::zb::dcts::node::detection::HistoryThresholdParam* history_threshold_;
  ::zb::dcts::node::detection::UserThresholdParam* user_threshold_;
  ::zb::dcts::node::detection::AdaptiveThresholdParam* adaptive_threshold_;
  int logic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class ThresholdRefLine PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.ThresholdRefLine) */ {
 public:
  inline ThresholdRefLine() : ThresholdRefLine(nullptr) {}
  virtual ~ThresholdRefLine();
  explicit constexpr ThresholdRefLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThresholdRefLine(const ThresholdRefLine& from);
  ThresholdRefLine(ThresholdRefLine&& from) noexcept
    : ThresholdRefLine() {
    *this = ::std::move(from);
  }

  inline ThresholdRefLine& operator=(const ThresholdRefLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdRefLine& operator=(ThresholdRefLine&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThresholdRefLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThresholdRefLine* internal_default_instance() {
    return reinterpret_cast<const ThresholdRefLine*>(
               &_ThresholdRefLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ThresholdRefLine& a, ThresholdRefLine& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdRefLine* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdRefLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThresholdRefLine* New() const final {
    return CreateMaybeMessage<ThresholdRefLine>(nullptr);
  }

  ThresholdRefLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdRefLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThresholdRefLine& from);
  void MergeFrom(const ThresholdRefLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdRefLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.ThresholdRefLine";
  }
  protected:
  explicit ThresholdRefLine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdTraceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated float threshold_trace = 2;
  int threshold_trace_size() const;
  private:
  int _internal_threshold_trace_size() const;
  public:
  void clear_threshold_trace();
  private:
  float _internal_threshold_trace(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_threshold_trace() const;
  void _internal_add_threshold_trace(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_threshold_trace();
  public:
  float threshold_trace(int index) const;
  void set_threshold_trace(int index, float value);
  void add_threshold_trace(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      threshold_trace() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_threshold_trace();

  // .zb.dcts.node.detection.ThresholdType type = 1;
  void clear_type();
  ::zb::dcts::node::detection::ThresholdType type() const;
  void set_type(::zb::dcts::node::detection::ThresholdType value);
  private:
  ::zb::dcts::node::detection::ThresholdType _internal_type() const;
  void _internal_set_type(::zb::dcts::node::detection::ThresholdType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.ThresholdRefLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > threshold_trace_;
  mutable std::atomic<int> _threshold_trace_cached_byte_size_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalFeature PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.SignalFeature) */ {
 public:
  inline SignalFeature() : SignalFeature(nullptr) {}
  virtual ~SignalFeature();
  explicit constexpr SignalFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalFeature(const SignalFeature& from);
  SignalFeature(SignalFeature&& from) noexcept
    : SignalFeature() {
    *this = ::std::move(from);
  }

  inline SignalFeature& operator=(const SignalFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalFeature& operator=(SignalFeature&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalFeature& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalFeature* internal_default_instance() {
    return reinterpret_cast<const SignalFeature*>(
               &_SignalFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignalFeature& a, SignalFeature& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalFeature* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalFeature* New() const final {
    return CreateMaybeMessage<SignalFeature>(nullptr);
  }

  SignalFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalFeature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalFeature& from);
  void MergeFrom(const SignalFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalFeature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.SignalFeature";
  }
  protected:
  explicit SignalFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpectrumDetailFieldNumber = 8,
    kHitsDetailFieldNumber = 9,
    kTimeSpanFieldNumber = 1,
    kSignalBandFieldNumber = 2,
    kAmplitudeFieldNumber = 4,
    kHitsFieldNumber = 5,
    kNumSweepFieldNumber = 3,
  };
  // repeated float spectrum_detail = 8;
  int spectrum_detail_size() const;
  private:
  int _internal_spectrum_detail_size() const;
  public:
  void clear_spectrum_detail();
  private:
  float _internal_spectrum_detail(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_spectrum_detail() const;
  void _internal_add_spectrum_detail(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_spectrum_detail();
  public:
  float spectrum_detail(int index) const;
  void set_spectrum_detail(int index, float value);
  void add_spectrum_detail(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      spectrum_detail() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_spectrum_detail();

  // repeated float hits_detail = 9;
  int hits_detail_size() const;
  private:
  int _internal_hits_detail_size() const;
  public:
  void clear_hits_detail();
  private:
  float _internal_hits_detail(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_hits_detail() const;
  void _internal_add_hits_detail(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_hits_detail();
  public:
  float hits_detail(int index) const;
  void set_hits_detail(int index, float value);
  void add_hits_detail(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      hits_detail() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_hits_detail();

  // .zb.dcts.TimeSpan time_span = 1;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // .zb.dcts.node.spectrum.SignalBand signal_band = 2;
  bool has_signal_band() const;
  private:
  bool _internal_has_signal_band() const;
  public:
  void clear_signal_band();
  const ::zb::dcts::node::spectrum::SignalBand& signal_band() const;
  ::zb::dcts::node::spectrum::SignalBand* release_signal_band();
  ::zb::dcts::node::spectrum::SignalBand* mutable_signal_band();
  void set_allocated_signal_band(::zb::dcts::node::spectrum::SignalBand* signal_band);
  private:
  const ::zb::dcts::node::spectrum::SignalBand& _internal_signal_band() const;
  ::zb::dcts::node::spectrum::SignalBand* _internal_mutable_signal_band();
  public:
  void unsafe_arena_set_allocated_signal_band(
      ::zb::dcts::node::spectrum::SignalBand* signal_band);
  ::zb::dcts::node::spectrum::SignalBand* unsafe_arena_release_signal_band();

  // .zb.dcts.StatisticVal amplitude = 4;
  bool has_amplitude() const;
  private:
  bool _internal_has_amplitude() const;
  public:
  void clear_amplitude();
  const ::zb::dcts::StatisticVal& amplitude() const;
  ::zb::dcts::StatisticVal* release_amplitude();
  ::zb::dcts::StatisticVal* mutable_amplitude();
  void set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude);
  private:
  const ::zb::dcts::StatisticVal& _internal_amplitude() const;
  ::zb::dcts::StatisticVal* _internal_mutable_amplitude();
  public:
  void unsafe_arena_set_allocated_amplitude(
      ::zb::dcts::StatisticVal* amplitude);
  ::zb::dcts::StatisticVal* unsafe_arena_release_amplitude();

  // .zb.dcts.StatisticVal hits = 5;
  bool has_hits() const;
  private:
  bool _internal_has_hits() const;
  public:
  void clear_hits();
  const ::zb::dcts::StatisticVal& hits() const;
  ::zb::dcts::StatisticVal* release_hits();
  ::zb::dcts::StatisticVal* mutable_hits();
  void set_allocated_hits(::zb::dcts::StatisticVal* hits);
  private:
  const ::zb::dcts::StatisticVal& _internal_hits() const;
  ::zb::dcts::StatisticVal* _internal_mutable_hits();
  public:
  void unsafe_arena_set_allocated_hits(
      ::zb::dcts::StatisticVal* hits);
  ::zb::dcts::StatisticVal* unsafe_arena_release_hits();

  // int32 num_sweep = 3;
  void clear_num_sweep();
  ::PROTOBUF_NAMESPACE_ID::int32 num_sweep() const;
  void set_num_sweep(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_sweep() const;
  void _internal_set_num_sweep(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.SignalFeature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > spectrum_detail_;
  mutable std::atomic<int> _spectrum_detail_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > hits_detail_;
  mutable std::atomic<int> _hits_detail_cached_byte_size_;
  ::zb::dcts::TimeSpan* time_span_;
  ::zb::dcts::node::spectrum::SignalBand* signal_band_;
  ::zb::dcts::StatisticVal* amplitude_;
  ::zb::dcts::StatisticVal* hits_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_sweep_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.SignalSegment) */ {
 public:
  inline SignalSegment() : SignalSegment(nullptr) {}
  virtual ~SignalSegment();
  explicit constexpr SignalSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalSegment(const SignalSegment& from);
  SignalSegment(SignalSegment&& from) noexcept
    : SignalSegment() {
    *this = ::std::move(from);
  }

  inline SignalSegment& operator=(const SignalSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalSegment& operator=(SignalSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalSegment* internal_default_instance() {
    return reinterpret_cast<const SignalSegment*>(
               &_SignalSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SignalSegment& a, SignalSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalSegment* New() const final {
    return CreateMaybeMessage<SignalSegment>(nullptr);
  }

  SignalSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalSegment& from);
  void MergeFrom(const SignalSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.SignalSegment";
  }
  protected:
  explicit SignalSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureFieldNumber = 9,
    kIdFieldNumber = 1,
    kCenterFreqFieldNumber = 3,
    kBandWidthFieldNumber = 4,
    kAmplitudeFieldNumber = 5,
    kTimeSpanFieldNumber = 6,
    kSegmentSeqFieldNumber = 2,
    kTotalSweepFieldNumber = 7,
    kTotalHitsFieldNumber = 8,
  };
  // repeated .zb.dcts.node.detection.SignalFeature feature = 9;
  int feature_size() const;
  private:
  int _internal_feature_size() const;
  public:
  void clear_feature();
  ::zb::dcts::node::detection::SignalFeature* mutable_feature(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalFeature >*
      mutable_feature();
  private:
  const ::zb::dcts::node::detection::SignalFeature& _internal_feature(int index) const;
  ::zb::dcts::node::detection::SignalFeature* _internal_add_feature();
  public:
  const ::zb::dcts::node::detection::SignalFeature& feature(int index) const;
  ::zb::dcts::node::detection::SignalFeature* add_feature();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalFeature >&
      feature() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .zb.dcts.StatisticVal center_freq = 3;
  bool has_center_freq() const;
  private:
  bool _internal_has_center_freq() const;
  public:
  void clear_center_freq();
  const ::zb::dcts::StatisticVal& center_freq() const;
  ::zb::dcts::StatisticVal* release_center_freq();
  ::zb::dcts::StatisticVal* mutable_center_freq();
  void set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq);
  private:
  const ::zb::dcts::StatisticVal& _internal_center_freq() const;
  ::zb::dcts::StatisticVal* _internal_mutable_center_freq();
  public:
  void unsafe_arena_set_allocated_center_freq(
      ::zb::dcts::StatisticVal* center_freq);
  ::zb::dcts::StatisticVal* unsafe_arena_release_center_freq();

  // .zb.dcts.StatisticVal band_width = 4;
  bool has_band_width() const;
  private:
  bool _internal_has_band_width() const;
  public:
  void clear_band_width();
  const ::zb::dcts::StatisticVal& band_width() const;
  ::zb::dcts::StatisticVal* release_band_width();
  ::zb::dcts::StatisticVal* mutable_band_width();
  void set_allocated_band_width(::zb::dcts::StatisticVal* band_width);
  private:
  const ::zb::dcts::StatisticVal& _internal_band_width() const;
  ::zb::dcts::StatisticVal* _internal_mutable_band_width();
  public:
  void unsafe_arena_set_allocated_band_width(
      ::zb::dcts::StatisticVal* band_width);
  ::zb::dcts::StatisticVal* unsafe_arena_release_band_width();

  // .zb.dcts.StatisticVal amplitude = 5;
  bool has_amplitude() const;
  private:
  bool _internal_has_amplitude() const;
  public:
  void clear_amplitude();
  const ::zb::dcts::StatisticVal& amplitude() const;
  ::zb::dcts::StatisticVal* release_amplitude();
  ::zb::dcts::StatisticVal* mutable_amplitude();
  void set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude);
  private:
  const ::zb::dcts::StatisticVal& _internal_amplitude() const;
  ::zb::dcts::StatisticVal* _internal_mutable_amplitude();
  public:
  void unsafe_arena_set_allocated_amplitude(
      ::zb::dcts::StatisticVal* amplitude);
  ::zb::dcts::StatisticVal* unsafe_arena_release_amplitude();

  // .zb.dcts.TimeSpan time_span = 6;
  bool has_time_span() const;
  private:
  bool _internal_has_time_span() const;
  public:
  void clear_time_span();
  const ::zb::dcts::TimeSpan& time_span() const;
  ::zb::dcts::TimeSpan* release_time_span();
  ::zb::dcts::TimeSpan* mutable_time_span();
  void set_allocated_time_span(::zb::dcts::TimeSpan* time_span);
  private:
  const ::zb::dcts::TimeSpan& _internal_time_span() const;
  ::zb::dcts::TimeSpan* _internal_mutable_time_span();
  public:
  void unsafe_arena_set_allocated_time_span(
      ::zb::dcts::TimeSpan* time_span);
  ::zb::dcts::TimeSpan* unsafe_arena_release_time_span();

  // int32 segment_seq = 2;
  void clear_segment_seq();
  ::PROTOBUF_NAMESPACE_ID::int32 segment_seq() const;
  void set_segment_seq(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_segment_seq() const;
  void _internal_set_segment_seq(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 total_sweep = 7;
  void clear_total_sweep();
  ::PROTOBUF_NAMESPACE_ID::int32 total_sweep() const;
  void set_total_sweep(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_sweep() const;
  void _internal_set_total_sweep(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 total_hits = 8;
  void clear_total_hits();
  ::PROTOBUF_NAMESPACE_ID::int32 total_hits() const;
  void set_total_hits(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_hits() const;
  void _internal_set_total_hits(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.SignalSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalFeature > feature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::zb::dcts::StatisticVal* center_freq_;
  ::zb::dcts::StatisticVal* band_width_;
  ::zb::dcts::StatisticVal* amplitude_;
  ::zb::dcts::TimeSpan* time_span_;
  ::PROTOBUF_NAMESPACE_ID::int32 segment_seq_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_sweep_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_hits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class HitsSegmentation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.HitsSegmentation) */ {
 public:
  inline HitsSegmentation() : HitsSegmentation(nullptr) {}
  virtual ~HitsSegmentation();
  explicit constexpr HitsSegmentation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HitsSegmentation(const HitsSegmentation& from);
  HitsSegmentation(HitsSegmentation&& from) noexcept
    : HitsSegmentation() {
    *this = ::std::move(from);
  }

  inline HitsSegmentation& operator=(const HitsSegmentation& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitsSegmentation& operator=(HitsSegmentation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HitsSegmentation& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitsSegmentation* internal_default_instance() {
    return reinterpret_cast<const HitsSegmentation*>(
               &_HitsSegmentation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HitsSegmentation& a, HitsSegmentation& b) {
    a.Swap(&b);
  }
  inline void Swap(HitsSegmentation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitsSegmentation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HitsSegmentation* New() const final {
    return CreateMaybeMessage<HitsSegmentation>(nullptr);
  }

  HitsSegmentation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HitsSegmentation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HitsSegmentation& from);
  void MergeFrom(const HitsSegmentation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HitsSegmentation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.HitsSegmentation";
  }
  protected:
  explicit HitsSegmentation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitsProbFieldNumber = 1,
    kBandwidthRangeFieldNumber = 2,
  };
  // repeated .zb.dcts.DRange hits_prob = 1;
  int hits_prob_size() const;
  private:
  int _internal_hits_prob_size() const;
  public:
  void clear_hits_prob();
  ::zb::dcts::DRange* mutable_hits_prob(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::DRange >*
      mutable_hits_prob();
  private:
  const ::zb::dcts::DRange& _internal_hits_prob(int index) const;
  ::zb::dcts::DRange* _internal_add_hits_prob();
  public:
  const ::zb::dcts::DRange& hits_prob(int index) const;
  ::zb::dcts::DRange* add_hits_prob();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::DRange >&
      hits_prob() const;

  // .zb.dcts.DRange bandwidth_range = 2;
  bool has_bandwidth_range() const;
  private:
  bool _internal_has_bandwidth_range() const;
  public:
  void clear_bandwidth_range();
  const ::zb::dcts::DRange& bandwidth_range() const;
  ::zb::dcts::DRange* release_bandwidth_range();
  ::zb::dcts::DRange* mutable_bandwidth_range();
  void set_allocated_bandwidth_range(::zb::dcts::DRange* bandwidth_range);
  private:
  const ::zb::dcts::DRange& _internal_bandwidth_range() const;
  ::zb::dcts::DRange* _internal_mutable_bandwidth_range();
  public:
  void unsafe_arena_set_allocated_bandwidth_range(
      ::zb::dcts::DRange* bandwidth_range);
  ::zb::dcts::DRange* unsafe_arena_release_bandwidth_range();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.HitsSegmentation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::DRange > hits_prob_;
  ::zb::dcts::DRange* bandwidth_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SegmentationParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.SegmentationParam) */ {
 public:
  inline SegmentationParam() : SegmentationParam(nullptr) {}
  virtual ~SegmentationParam();
  explicit constexpr SegmentationParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SegmentationParam(const SegmentationParam& from);
  SegmentationParam(SegmentationParam&& from) noexcept
    : SegmentationParam() {
    *this = ::std::move(from);
  }

  inline SegmentationParam& operator=(const SegmentationParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentationParam& operator=(SegmentationParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SegmentationParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const SegmentationParam* internal_default_instance() {
    return reinterpret_cast<const SegmentationParam*>(
               &_SegmentationParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SegmentationParam& a, SegmentationParam& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentationParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentationParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SegmentationParam* New() const final {
    return CreateMaybeMessage<SegmentationParam>(nullptr);
  }

  SegmentationParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SegmentationParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SegmentationParam& from);
  void MergeFrom(const SegmentationParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentationParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.SegmentationParam";
  }
  protected:
  explicit SegmentationParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitsParamFieldNumber = 3,
    kEnableFiltersFieldNumber = 1,
    kNumOverlapFieldNumber = 2,
  };
  // .zb.dcts.node.detection.HitsSegmentation hits_param = 3;
  bool has_hits_param() const;
  private:
  bool _internal_has_hits_param() const;
  public:
  void clear_hits_param();
  const ::zb::dcts::node::detection::HitsSegmentation& hits_param() const;
  ::zb::dcts::node::detection::HitsSegmentation* release_hits_param();
  ::zb::dcts::node::detection::HitsSegmentation* mutable_hits_param();
  void set_allocated_hits_param(::zb::dcts::node::detection::HitsSegmentation* hits_param);
  private:
  const ::zb::dcts::node::detection::HitsSegmentation& _internal_hits_param() const;
  ::zb::dcts::node::detection::HitsSegmentation* _internal_mutable_hits_param();
  public:
  void unsafe_arena_set_allocated_hits_param(
      ::zb::dcts::node::detection::HitsSegmentation* hits_param);
  ::zb::dcts::node::detection::HitsSegmentation* unsafe_arena_release_hits_param();

  // uint32 enable_filters = 1;
  void clear_enable_filters();
  ::PROTOBUF_NAMESPACE_ID::uint32 enable_filters() const;
  void set_enable_filters(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_enable_filters() const;
  void _internal_set_enable_filters(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 num_overlap = 2;
  void clear_num_overlap();
  ::PROTOBUF_NAMESPACE_ID::int32 num_overlap() const;
  void set_num_overlap(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_overlap() const;
  void _internal_set_num_overlap(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.SegmentationParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::detection::HitsSegmentation* hits_param_;
  ::PROTOBUF_NAMESPACE_ID::uint32 enable_filters_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_overlap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SpectrumIntersection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.SpectrumIntersection) */ {
 public:
  inline SpectrumIntersection() : SpectrumIntersection(nullptr) {}
  virtual ~SpectrumIntersection();
  explicit constexpr SpectrumIntersection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpectrumIntersection(const SpectrumIntersection& from);
  SpectrumIntersection(SpectrumIntersection&& from) noexcept
    : SpectrumIntersection() {
    *this = ::std::move(from);
  }

  inline SpectrumIntersection& operator=(const SpectrumIntersection& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpectrumIntersection& operator=(SpectrumIntersection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpectrumIntersection& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpectrumIntersection* internal_default_instance() {
    return reinterpret_cast<const SpectrumIntersection*>(
               &_SpectrumIntersection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpectrumIntersection& a, SpectrumIntersection& b) {
    a.Swap(&b);
  }
  inline void Swap(SpectrumIntersection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpectrumIntersection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpectrumIntersection* New() const final {
    return CreateMaybeMessage<SpectrumIntersection>(nullptr);
  }

  SpectrumIntersection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpectrumIntersection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpectrumIntersection& from);
  void MergeFrom(const SpectrumIntersection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpectrumIntersection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.SpectrumIntersection";
  }
  protected:
  explicit SpectrumIntersection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinIntersectionRatioFieldNumber = 1,
    kMaxTimeGapFieldNumber = 2,
  };
  // float min_intersection_ratio = 1;
  void clear_min_intersection_ratio();
  float min_intersection_ratio() const;
  void set_min_intersection_ratio(float value);
  private:
  float _internal_min_intersection_ratio() const;
  void _internal_set_min_intersection_ratio(float value);
  public:

  // int32 max_time_gap = 2;
  void clear_max_time_gap();
  ::PROTOBUF_NAMESPACE_ID::int32 max_time_gap() const;
  void set_max_time_gap(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_time_gap() const;
  void _internal_set_max_time_gap(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.SpectrumIntersection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float min_intersection_ratio_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_time_gap_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class MergeParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.MergeParam) */ {
 public:
  inline MergeParam() : MergeParam(nullptr) {}
  virtual ~MergeParam();
  explicit constexpr MergeParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeParam(const MergeParam& from);
  MergeParam(MergeParam&& from) noexcept
    : MergeParam() {
    *this = ::std::move(from);
  }

  inline MergeParam& operator=(const MergeParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeParam& operator=(MergeParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MergeParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeParam* internal_default_instance() {
    return reinterpret_cast<const MergeParam*>(
               &_MergeParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MergeParam& a, MergeParam& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MergeParam* New() const final {
    return CreateMaybeMessage<MergeParam>(nullptr);
  }

  MergeParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MergeParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MergeParam& from);
  void MergeFrom(const MergeParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.MergeParam";
  }
  protected:
  explicit MergeParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureMergeParamFieldNumber = 3,
    kSignalMergeParamFieldNumber = 4,
    kPolicyFieldNumber = 1,
  };
  // .zb.dcts.node.detection.SpectrumIntersection feature_merge_param = 3;
  bool has_feature_merge_param() const;
  private:
  bool _internal_has_feature_merge_param() const;
  public:
  void clear_feature_merge_param();
  const ::zb::dcts::node::detection::SpectrumIntersection& feature_merge_param() const;
  ::zb::dcts::node::detection::SpectrumIntersection* release_feature_merge_param();
  ::zb::dcts::node::detection::SpectrumIntersection* mutable_feature_merge_param();
  void set_allocated_feature_merge_param(::zb::dcts::node::detection::SpectrumIntersection* feature_merge_param);
  private:
  const ::zb::dcts::node::detection::SpectrumIntersection& _internal_feature_merge_param() const;
  ::zb::dcts::node::detection::SpectrumIntersection* _internal_mutable_feature_merge_param();
  public:
  void unsafe_arena_set_allocated_feature_merge_param(
      ::zb::dcts::node::detection::SpectrumIntersection* feature_merge_param);
  ::zb::dcts::node::detection::SpectrumIntersection* unsafe_arena_release_feature_merge_param();

  // .zb.dcts.node.detection.SpectrumIntersection signal_merge_param = 4;
  bool has_signal_merge_param() const;
  private:
  bool _internal_has_signal_merge_param() const;
  public:
  void clear_signal_merge_param();
  const ::zb::dcts::node::detection::SpectrumIntersection& signal_merge_param() const;
  ::zb::dcts::node::detection::SpectrumIntersection* release_signal_merge_param();
  ::zb::dcts::node::detection::SpectrumIntersection* mutable_signal_merge_param();
  void set_allocated_signal_merge_param(::zb::dcts::node::detection::SpectrumIntersection* signal_merge_param);
  private:
  const ::zb::dcts::node::detection::SpectrumIntersection& _internal_signal_merge_param() const;
  ::zb::dcts::node::detection::SpectrumIntersection* _internal_mutable_signal_merge_param();
  public:
  void unsafe_arena_set_allocated_signal_merge_param(
      ::zb::dcts::node::detection::SpectrumIntersection* signal_merge_param);
  ::zb::dcts::node::detection::SpectrumIntersection* unsafe_arena_release_signal_merge_param();

  // .zb.dcts.node.detection.MergePolicy policy = 1;
  void clear_policy();
  ::zb::dcts::node::detection::MergePolicy policy() const;
  void set_policy(::zb::dcts::node::detection::MergePolicy value);
  private:
  ::zb::dcts::node::detection::MergePolicy _internal_policy() const;
  void _internal_set_policy(::zb::dcts::node::detection::MergePolicy value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.MergeParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::detection::SpectrumIntersection* feature_merge_param_;
  ::zb::dcts::node::detection::SpectrumIntersection* signal_merge_param_;
  int policy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetectionOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.DetectionOption) */ {
 public:
  inline DetectionOption() : DetectionOption(nullptr) {}
  virtual ~DetectionOption();
  explicit constexpr DetectionOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionOption(const DetectionOption& from);
  DetectionOption(DetectionOption&& from) noexcept
    : DetectionOption() {
    *this = ::std::move(from);
  }

  inline DetectionOption& operator=(const DetectionOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionOption& operator=(DetectionOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetectionOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionOption* internal_default_instance() {
    return reinterpret_cast<const DetectionOption*>(
               &_DetectionOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DetectionOption& a, DetectionOption& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionOption* New() const final {
    return CreateMaybeMessage<DetectionOption>(nullptr);
  }

  DetectionOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetectionOption& from);
  void MergeFrom(const DetectionOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.DetectionOption";
  }
  protected:
  explicit DetectionOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClearSignalLibHistoryFieldNumber = 1,
    kCommitResultPeriodFieldNumber = 3,
  };
  // .zb.dcts.Boolean clear_signal_lib_history = 1;
  bool has_clear_signal_lib_history() const;
  private:
  bool _internal_has_clear_signal_lib_history() const;
  public:
  void clear_clear_signal_lib_history();
  const ::zb::dcts::Boolean& clear_signal_lib_history() const;
  ::zb::dcts::Boolean* release_clear_signal_lib_history();
  ::zb::dcts::Boolean* mutable_clear_signal_lib_history();
  void set_allocated_clear_signal_lib_history(::zb::dcts::Boolean* clear_signal_lib_history);
  private:
  const ::zb::dcts::Boolean& _internal_clear_signal_lib_history() const;
  ::zb::dcts::Boolean* _internal_mutable_clear_signal_lib_history();
  public:
  void unsafe_arena_set_allocated_clear_signal_lib_history(
      ::zb::dcts::Boolean* clear_signal_lib_history);
  ::zb::dcts::Boolean* unsafe_arena_release_clear_signal_lib_history();

  // .zb.dcts.Integer commit_result_period = 3;
  bool has_commit_result_period() const;
  private:
  bool _internal_has_commit_result_period() const;
  public:
  void clear_commit_result_period();
  const ::zb::dcts::Integer& commit_result_period() const;
  ::zb::dcts::Integer* release_commit_result_period();
  ::zb::dcts::Integer* mutable_commit_result_period();
  void set_allocated_commit_result_period(::zb::dcts::Integer* commit_result_period);
  private:
  const ::zb::dcts::Integer& _internal_commit_result_period() const;
  ::zb::dcts::Integer* _internal_mutable_commit_result_period();
  public:
  void unsafe_arena_set_allocated_commit_result_period(
      ::zb::dcts::Integer* commit_result_period);
  ::zb::dcts::Integer* unsafe_arena_release_commit_result_period();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.DetectionOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::Boolean* clear_signal_lib_history_;
  ::zb::dcts::Integer* commit_result_period_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetectionParam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.DetectionParam) */ {
 public:
  inline DetectionParam() : DetectionParam(nullptr) {}
  virtual ~DetectionParam();
  explicit constexpr DetectionParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionParam(const DetectionParam& from);
  DetectionParam(DetectionParam&& from) noexcept
    : DetectionParam() {
    *this = ::std::move(from);
  }

  inline DetectionParam& operator=(const DetectionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionParam& operator=(DetectionParam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetectionParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionParam* internal_default_instance() {
    return reinterpret_cast<const DetectionParam*>(
               &_DetectionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DetectionParam& a, DetectionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionParam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionParam* New() const final {
    return CreateMaybeMessage<DetectionParam>(nullptr);
  }

  DetectionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionParam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetectionParam& from);
  void MergeFrom(const DetectionParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.DetectionParam";
  }
  protected:
  explicit DetectionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnergyDetectParamFieldNumber = 1,
    kSegmentationParamFieldNumber = 3,
    kMergeParamFieldNumber = 4,
    kOptionsFieldNumber = 5,
  };
  // .zb.dcts.node.detection.EnergyDetectionParam energy_detect_param = 1;
  bool has_energy_detect_param() const;
  private:
  bool _internal_has_energy_detect_param() const;
  public:
  void clear_energy_detect_param();
  const ::zb::dcts::node::detection::EnergyDetectionParam& energy_detect_param() const;
  ::zb::dcts::node::detection::EnergyDetectionParam* release_energy_detect_param();
  ::zb::dcts::node::detection::EnergyDetectionParam* mutable_energy_detect_param();
  void set_allocated_energy_detect_param(::zb::dcts::node::detection::EnergyDetectionParam* energy_detect_param);
  private:
  const ::zb::dcts::node::detection::EnergyDetectionParam& _internal_energy_detect_param() const;
  ::zb::dcts::node::detection::EnergyDetectionParam* _internal_mutable_energy_detect_param();
  public:
  void unsafe_arena_set_allocated_energy_detect_param(
      ::zb::dcts::node::detection::EnergyDetectionParam* energy_detect_param);
  ::zb::dcts::node::detection::EnergyDetectionParam* unsafe_arena_release_energy_detect_param();

  // .zb.dcts.node.detection.SegmentationParam segmentation_param = 3;
  bool has_segmentation_param() const;
  private:
  bool _internal_has_segmentation_param() const;
  public:
  void clear_segmentation_param();
  const ::zb::dcts::node::detection::SegmentationParam& segmentation_param() const;
  ::zb::dcts::node::detection::SegmentationParam* release_segmentation_param();
  ::zb::dcts::node::detection::SegmentationParam* mutable_segmentation_param();
  void set_allocated_segmentation_param(::zb::dcts::node::detection::SegmentationParam* segmentation_param);
  private:
  const ::zb::dcts::node::detection::SegmentationParam& _internal_segmentation_param() const;
  ::zb::dcts::node::detection::SegmentationParam* _internal_mutable_segmentation_param();
  public:
  void unsafe_arena_set_allocated_segmentation_param(
      ::zb::dcts::node::detection::SegmentationParam* segmentation_param);
  ::zb::dcts::node::detection::SegmentationParam* unsafe_arena_release_segmentation_param();

  // .zb.dcts.node.detection.MergeParam merge_param = 4;
  bool has_merge_param() const;
  private:
  bool _internal_has_merge_param() const;
  public:
  void clear_merge_param();
  const ::zb::dcts::node::detection::MergeParam& merge_param() const;
  ::zb::dcts::node::detection::MergeParam* release_merge_param();
  ::zb::dcts::node::detection::MergeParam* mutable_merge_param();
  void set_allocated_merge_param(::zb::dcts::node::detection::MergeParam* merge_param);
  private:
  const ::zb::dcts::node::detection::MergeParam& _internal_merge_param() const;
  ::zb::dcts::node::detection::MergeParam* _internal_mutable_merge_param();
  public:
  void unsafe_arena_set_allocated_merge_param(
      ::zb::dcts::node::detection::MergeParam* merge_param);
  ::zb::dcts::node::detection::MergeParam* unsafe_arena_release_merge_param();

  // .zb.dcts.node.detection.DetectionOption options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::zb::dcts::node::detection::DetectionOption& options() const;
  ::zb::dcts::node::detection::DetectionOption* release_options();
  ::zb::dcts::node::detection::DetectionOption* mutable_options();
  void set_allocated_options(::zb::dcts::node::detection::DetectionOption* options);
  private:
  const ::zb::dcts::node::detection::DetectionOption& _internal_options() const;
  ::zb::dcts::node::detection::DetectionOption* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::zb::dcts::node::detection::DetectionOption* options);
  ::zb::dcts::node::detection::DetectionOption* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.DetectionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::detection::EnergyDetectionParam* energy_detect_param_;
  ::zb::dcts::node::detection::SegmentationParam* segmentation_param_;
  ::zb::dcts::node::detection::MergeParam* merge_param_;
  ::zb::dcts::node::detection::DetectionOption* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class SignalList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.SignalList) */ {
 public:
  inline SignalList() : SignalList(nullptr) {}
  virtual ~SignalList();
  explicit constexpr SignalList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalList(const SignalList& from);
  SignalList(SignalList&& from) noexcept
    : SignalList() {
    *this = ::std::move(from);
  }

  inline SignalList& operator=(const SignalList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalList& operator=(SignalList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalList* internal_default_instance() {
    return reinterpret_cast<const SignalList*>(
               &_SignalList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SignalList& a, SignalList& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalList* New() const final {
    return CreateMaybeMessage<SignalList>(nullptr);
  }

  SignalList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalList& from);
  void MergeFrom(const SignalList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.SignalList";
  }
  protected:
  explicit SignalList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectedSignalsFieldNumber = 1,
    kMergedSignalIdFieldNumber = 2,
  };
  // repeated .zb.dcts.node.detection.SignalSegment detected_signals = 1;
  int detected_signals_size() const;
  private:
  int _internal_detected_signals_size() const;
  public:
  void clear_detected_signals();
  ::zb::dcts::node::detection::SignalSegment* mutable_detected_signals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalSegment >*
      mutable_detected_signals();
  private:
  const ::zb::dcts::node::detection::SignalSegment& _internal_detected_signals(int index) const;
  ::zb::dcts::node::detection::SignalSegment* _internal_add_detected_signals();
  public:
  const ::zb::dcts::node::detection::SignalSegment& detected_signals(int index) const;
  ::zb::dcts::node::detection::SignalSegment* add_detected_signals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalSegment >&
      detected_signals() const;

  // repeated string merged_signal_id = 2;
  int merged_signal_id_size() const;
  private:
  int _internal_merged_signal_id_size() const;
  public:
  void clear_merged_signal_id();
  const std::string& merged_signal_id(int index) const;
  std::string* mutable_merged_signal_id(int index);
  void set_merged_signal_id(int index, const std::string& value);
  void set_merged_signal_id(int index, std::string&& value);
  void set_merged_signal_id(int index, const char* value);
  void set_merged_signal_id(int index, const char* value, size_t size);
  std::string* add_merged_signal_id();
  void add_merged_signal_id(const std::string& value);
  void add_merged_signal_id(std::string&& value);
  void add_merged_signal_id(const char* value);
  void add_merged_signal_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& merged_signal_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_merged_signal_id();
  private:
  const std::string& _internal_merged_signal_id(int index) const;
  std::string* _internal_add_merged_signal_id();
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.SignalList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalSegment > detected_signals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> merged_signal_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetectionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.DetectionRequest) */ {
 public:
  inline DetectionRequest() : DetectionRequest(nullptr) {}
  virtual ~DetectionRequest();
  explicit constexpr DetectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionRequest(const DetectionRequest& from);
  DetectionRequest(DetectionRequest&& from) noexcept
    : DetectionRequest() {
    *this = ::std::move(from);
  }

  inline DetectionRequest& operator=(const DetectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionRequest& operator=(DetectionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionRequest* internal_default_instance() {
    return reinterpret_cast<const DetectionRequest*>(
               &_DetectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DetectionRequest& a, DetectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetectionRequest* New() const final {
    return CreateMaybeMessage<DetectionRequest>(nullptr);
  }

  DetectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetectionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetectionRequest& from);
  void MergeFrom(const DetectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.DetectionRequest";
  }
  protected:
  explicit DetectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskAccountFieldNumber = 1,
    kDetectionParamFieldNumber = 2,
  };
  // .zb.dcts.node.TaskAccount task_account = 1;
  bool has_task_account() const;
  private:
  bool _internal_has_task_account() const;
  public:
  void clear_task_account();
  const ::zb::dcts::node::TaskAccount& task_account() const;
  ::zb::dcts::node::TaskAccount* release_task_account();
  ::zb::dcts::node::TaskAccount* mutable_task_account();
  void set_allocated_task_account(::zb::dcts::node::TaskAccount* task_account);
  private:
  const ::zb::dcts::node::TaskAccount& _internal_task_account() const;
  ::zb::dcts::node::TaskAccount* _internal_mutable_task_account();
  public:
  void unsafe_arena_set_allocated_task_account(
      ::zb::dcts::node::TaskAccount* task_account);
  ::zb::dcts::node::TaskAccount* unsafe_arena_release_task_account();

  // .zb.dcts.node.detection.DetectionParam detection_param = 2;
  bool has_detection_param() const;
  private:
  bool _internal_has_detection_param() const;
  public:
  void clear_detection_param();
  const ::zb::dcts::node::detection::DetectionParam& detection_param() const;
  ::zb::dcts::node::detection::DetectionParam* release_detection_param();
  ::zb::dcts::node::detection::DetectionParam* mutable_detection_param();
  void set_allocated_detection_param(::zb::dcts::node::detection::DetectionParam* detection_param);
  private:
  const ::zb::dcts::node::detection::DetectionParam& _internal_detection_param() const;
  ::zb::dcts::node::detection::DetectionParam* _internal_mutable_detection_param();
  public:
  void unsafe_arena_set_allocated_detection_param(
      ::zb::dcts::node::detection::DetectionParam* detection_param);
  ::zb::dcts::node::detection::DetectionParam* unsafe_arena_release_detection_param();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.DetectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::TaskAccount* task_account_;
  ::zb::dcts::node::detection::DetectionParam* detection_param_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetailKeeping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.DetailKeeping) */ {
 public:
  inline DetailKeeping() : DetailKeeping(nullptr) {}
  virtual ~DetailKeeping();
  explicit constexpr DetailKeeping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailKeeping(const DetailKeeping& from);
  DetailKeeping(DetailKeeping&& from) noexcept
    : DetailKeeping() {
    *this = ::std::move(from);
  }

  inline DetailKeeping& operator=(const DetailKeeping& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailKeeping& operator=(DetailKeeping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetailKeeping& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailKeeping* internal_default_instance() {
    return reinterpret_cast<const DetailKeeping*>(
               &_DetailKeeping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DetailKeeping& a, DetailKeeping& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailKeeping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailKeeping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetailKeeping* New() const final {
    return CreateMaybeMessage<DetailKeeping>(nullptr);
  }

  DetailKeeping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetailKeeping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetailKeeping& from);
  void MergeFrom(const DetailKeeping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailKeeping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.DetailKeeping";
  }
  protected:
  explicit DetailKeeping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignalIdFieldNumber = 1,
    kKeepingFieldNumber = 2,
  };
  // repeated string signal_id = 1;
  int signal_id_size() const;
  private:
  int _internal_signal_id_size() const;
  public:
  void clear_signal_id();
  const std::string& signal_id(int index) const;
  std::string* mutable_signal_id(int index);
  void set_signal_id(int index, const std::string& value);
  void set_signal_id(int index, std::string&& value);
  void set_signal_id(int index, const char* value);
  void set_signal_id(int index, const char* value, size_t size);
  std::string* add_signal_id();
  void add_signal_id(const std::string& value);
  void add_signal_id(std::string&& value);
  void add_signal_id(const char* value);
  void add_signal_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signal_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signal_id();
  private:
  const std::string& _internal_signal_id(int index) const;
  std::string* _internal_add_signal_id();
  public:

  // bool keeping = 2;
  void clear_keeping();
  bool keeping() const;
  void set_keeping(bool value);
  private:
  bool _internal_keeping() const;
  void _internal_set_keeping(bool value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.DetailKeeping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signal_id_;
  bool keeping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// -------------------------------------------------------------------

class DetailKeepingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.detection.DetailKeepingRequest) */ {
 public:
  inline DetailKeepingRequest() : DetailKeepingRequest(nullptr) {}
  virtual ~DetailKeepingRequest();
  explicit constexpr DetailKeepingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetailKeepingRequest(const DetailKeepingRequest& from);
  DetailKeepingRequest(DetailKeepingRequest&& from) noexcept
    : DetailKeepingRequest() {
    *this = ::std::move(from);
  }

  inline DetailKeepingRequest& operator=(const DetailKeepingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetailKeepingRequest& operator=(DetailKeepingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DetailKeepingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetailKeepingRequest* internal_default_instance() {
    return reinterpret_cast<const DetailKeepingRequest*>(
               &_DetailKeepingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DetailKeepingRequest& a, DetailKeepingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DetailKeepingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetailKeepingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DetailKeepingRequest* New() const final {
    return CreateMaybeMessage<DetailKeepingRequest>(nullptr);
  }

  DetailKeepingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DetailKeepingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DetailKeepingRequest& from);
  void MergeFrom(const DetailKeepingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetailKeepingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.detection.DetailKeepingRequest";
  }
  protected:
  explicit DetailKeepingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fdetection_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskAccountFieldNumber = 1,
    kDetailKeepingFieldNumber = 2,
  };
  // .zb.dcts.node.TaskAccount task_account = 1;
  bool has_task_account() const;
  private:
  bool _internal_has_task_account() const;
  public:
  void clear_task_account();
  const ::zb::dcts::node::TaskAccount& task_account() const;
  ::zb::dcts::node::TaskAccount* release_task_account();
  ::zb::dcts::node::TaskAccount* mutable_task_account();
  void set_allocated_task_account(::zb::dcts::node::TaskAccount* task_account);
  private:
  const ::zb::dcts::node::TaskAccount& _internal_task_account() const;
  ::zb::dcts::node::TaskAccount* _internal_mutable_task_account();
  public:
  void unsafe_arena_set_allocated_task_account(
      ::zb::dcts::node::TaskAccount* task_account);
  ::zb::dcts::node::TaskAccount* unsafe_arena_release_task_account();

  // .zb.dcts.node.detection.DetailKeeping detail_keeping = 2;
  bool has_detail_keeping() const;
  private:
  bool _internal_has_detail_keeping() const;
  public:
  void clear_detail_keeping();
  const ::zb::dcts::node::detection::DetailKeeping& detail_keeping() const;
  ::zb::dcts::node::detection::DetailKeeping* release_detail_keeping();
  ::zb::dcts::node::detection::DetailKeeping* mutable_detail_keeping();
  void set_allocated_detail_keeping(::zb::dcts::node::detection::DetailKeeping* detail_keeping);
  private:
  const ::zb::dcts::node::detection::DetailKeeping& _internal_detail_keeping() const;
  ::zb::dcts::node::detection::DetailKeeping* _internal_mutable_detail_keeping();
  public:
  void unsafe_arena_set_allocated_detail_keeping(
      ::zb::dcts::node::detection::DetailKeeping* detail_keeping);
  ::zb::dcts::node::detection::DetailKeeping* unsafe_arena_release_detail_keeping();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.detection.DetailKeepingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::TaskAccount* task_account_;
  ::zb::dcts::node::detection::DetailKeeping* detail_keeping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fdetection_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ThresholdSector

// .zb.dcts.node.spectrum.FrequencySpan freq_span = 1;
inline bool ThresholdSector::_internal_has_freq_span() const {
  return this != internal_default_instance() && freq_span_ != nullptr;
}
inline bool ThresholdSector::has_freq_span() const {
  return _internal_has_freq_span();
}
inline const ::zb::dcts::node::spectrum::FrequencySpan& ThresholdSector::_internal_freq_span() const {
  const ::zb::dcts::node::spectrum::FrequencySpan* p = freq_span_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::spectrum::FrequencySpan&>(
      ::zb::dcts::node::spectrum::_FrequencySpan_default_instance_);
}
inline const ::zb::dcts::node::spectrum::FrequencySpan& ThresholdSector::freq_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.ThresholdSector.freq_span)
  return _internal_freq_span();
}
inline void ThresholdSector::unsafe_arena_set_allocated_freq_span(
    ::zb::dcts::node::spectrum::FrequencySpan* freq_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  freq_span_ = freq_span;
  if (freq_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.ThresholdSector.freq_span)
}
inline ::zb::dcts::node::spectrum::FrequencySpan* ThresholdSector::release_freq_span() {
  
  ::zb::dcts::node::spectrum::FrequencySpan* temp = freq_span_;
  freq_span_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::spectrum::FrequencySpan* ThresholdSector::unsafe_arena_release_freq_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.ThresholdSector.freq_span)
  
  ::zb::dcts::node::spectrum::FrequencySpan* temp = freq_span_;
  freq_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::spectrum::FrequencySpan* ThresholdSector::_internal_mutable_freq_span() {
  
  if (freq_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::spectrum::FrequencySpan>(GetArena());
    freq_span_ = p;
  }
  return freq_span_;
}
inline ::zb::dcts::node::spectrum::FrequencySpan* ThresholdSector::mutable_freq_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.ThresholdSector.freq_span)
  return _internal_mutable_freq_span();
}
inline void ThresholdSector::set_allocated_freq_span(::zb::dcts::node::spectrum::FrequencySpan* freq_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span_);
  }
  if (freq_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(freq_span)->GetArena();
    if (message_arena != submessage_arena) {
      freq_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, freq_span, submessage_arena);
    }
    
  } else {
    
  }
  freq_span_ = freq_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.ThresholdSector.freq_span)
}

// float level = 2;
inline void ThresholdSector::clear_level() {
  level_ = 0;
}
inline float ThresholdSector::_internal_level() const {
  return level_;
}
inline float ThresholdSector::level() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.ThresholdSector.level)
  return _internal_level();
}
inline void ThresholdSector::_internal_set_level(float value) {
  
  level_ = value;
}
inline void ThresholdSector::set_level(float value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.ThresholdSector.level)
}

// -------------------------------------------------------------------

// HistoryThresholdParam

// .zb.dcts.TimeSpan span = 1;
inline bool HistoryThresholdParam::_internal_has_span() const {
  return this != internal_default_instance() && span_ != nullptr;
}
inline bool HistoryThresholdParam::has_span() const {
  return _internal_has_span();
}
inline const ::zb::dcts::TimeSpan& HistoryThresholdParam::_internal_span() const {
  const ::zb::dcts::TimeSpan* p = span_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TimeSpan&>(
      ::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& HistoryThresholdParam::span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.HistoryThresholdParam.span)
  return _internal_span();
}
inline void HistoryThresholdParam::unsafe_arena_set_allocated_span(
    ::zb::dcts::TimeSpan* span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(span_);
  }
  span_ = span;
  if (span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.HistoryThresholdParam.span)
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::release_span() {
  
  ::zb::dcts::TimeSpan* temp = span_;
  span_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::unsafe_arena_release_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.HistoryThresholdParam.span)
  
  ::zb::dcts::TimeSpan* temp = span_;
  span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::_internal_mutable_span() {
  
  if (span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    span_ = p;
  }
  return span_;
}
inline ::zb::dcts::TimeSpan* HistoryThresholdParam::mutable_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.HistoryThresholdParam.span)
  return _internal_mutable_span();
}
inline void HistoryThresholdParam::set_allocated_span(::zb::dcts::TimeSpan* span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(span_);
  }
  if (span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(span)->GetArena();
    if (message_arena != submessage_arena) {
      span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, span, submessage_arena);
    }
    
  } else {
    
  }
  span_ = span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.HistoryThresholdParam.span)
}

// int32 max_load_count = 3;
inline void HistoryThresholdParam::clear_max_load_count() {
  max_load_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HistoryThresholdParam::_internal_max_load_count() const {
  return max_load_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HistoryThresholdParam::max_load_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.HistoryThresholdParam.max_load_count)
  return _internal_max_load_count();
}
inline void HistoryThresholdParam::_internal_set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_load_count_ = value;
}
inline void HistoryThresholdParam::set_max_load_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_load_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.HistoryThresholdParam.max_load_count)
}

// float offset = 4;
inline void HistoryThresholdParam::clear_offset() {
  offset_ = 0;
}
inline float HistoryThresholdParam::_internal_offset() const {
  return offset_;
}
inline float HistoryThresholdParam::offset() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.HistoryThresholdParam.offset)
  return _internal_offset();
}
inline void HistoryThresholdParam::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void HistoryThresholdParam::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.HistoryThresholdParam.offset)
}

// -------------------------------------------------------------------

// UserThresholdParam

// repeated .zb.dcts.node.detection.ThresholdSector sectors = 1;
inline int UserThresholdParam::_internal_sectors_size() const {
  return sectors_.size();
}
inline int UserThresholdParam::sectors_size() const {
  return _internal_sectors_size();
}
inline void UserThresholdParam::clear_sectors() {
  sectors_.Clear();
}
inline ::zb::dcts::node::detection::ThresholdSector* UserThresholdParam::mutable_sectors(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.UserThresholdParam.sectors)
  return sectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::ThresholdSector >*
UserThresholdParam::mutable_sectors() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.UserThresholdParam.sectors)
  return &sectors_;
}
inline const ::zb::dcts::node::detection::ThresholdSector& UserThresholdParam::_internal_sectors(int index) const {
  return sectors_.Get(index);
}
inline const ::zb::dcts::node::detection::ThresholdSector& UserThresholdParam::sectors(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.UserThresholdParam.sectors)
  return _internal_sectors(index);
}
inline ::zb::dcts::node::detection::ThresholdSector* UserThresholdParam::_internal_add_sectors() {
  return sectors_.Add();
}
inline ::zb::dcts::node::detection::ThresholdSector* UserThresholdParam::add_sectors() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.UserThresholdParam.sectors)
  return _internal_add_sectors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::ThresholdSector >&
UserThresholdParam::sectors() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.UserThresholdParam.sectors)
  return sectors_;
}

// -------------------------------------------------------------------

// AdaptiveThresholdParam

// int32 average_count = 1;
inline void AdaptiveThresholdParam::clear_average_count() {
  average_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdaptiveThresholdParam::_internal_average_count() const {
  return average_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AdaptiveThresholdParam::average_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.AdaptiveThresholdParam.average_count)
  return _internal_average_count();
}
inline void AdaptiveThresholdParam::_internal_set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  average_count_ = value;
}
inline void AdaptiveThresholdParam::set_average_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_average_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.AdaptiveThresholdParam.average_count)
}

// .zb.dcts.node.detection.AdaptiveThresholdParam.PartitionMode partition_mode = 2;
inline void AdaptiveThresholdParam::clear_partition_mode() {
  partition_mode_ = 0;
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam::_internal_partition_mode() const {
  return static_cast< ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode >(partition_mode_);
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode AdaptiveThresholdParam::partition_mode() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.AdaptiveThresholdParam.partition_mode)
  return _internal_partition_mode();
}
inline void AdaptiveThresholdParam::_internal_set_partition_mode(::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode value) {
  
  partition_mode_ = value;
}
inline void AdaptiveThresholdParam::set_partition_mode(::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode value) {
  _internal_set_partition_mode(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.AdaptiveThresholdParam.partition_mode)
}

// float offset = 3;
inline void AdaptiveThresholdParam::clear_offset() {
  offset_ = 0;
}
inline float AdaptiveThresholdParam::_internal_offset() const {
  return offset_;
}
inline float AdaptiveThresholdParam::offset() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.AdaptiveThresholdParam.offset)
  return _internal_offset();
}
inline void AdaptiveThresholdParam::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void AdaptiveThresholdParam::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.AdaptiveThresholdParam.offset)
}

// -------------------------------------------------------------------

// EnergyDetectionParam

// repeated .zb.dcts.node.detection.ThresholdType active_types = 1;
inline int EnergyDetectionParam::_internal_active_types_size() const {
  return active_types_.size();
}
inline int EnergyDetectionParam::active_types_size() const {
  return _internal_active_types_size();
}
inline void EnergyDetectionParam::clear_active_types() {
  active_types_.Clear();
}
inline ::zb::dcts::node::detection::ThresholdType EnergyDetectionParam::_internal_active_types(int index) const {
  return static_cast< ::zb::dcts::node::detection::ThresholdType >(active_types_.Get(index));
}
inline ::zb::dcts::node::detection::ThresholdType EnergyDetectionParam::active_types(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.EnergyDetectionParam.active_types)
  return _internal_active_types(index);
}
inline void EnergyDetectionParam::set_active_types(int index, ::zb::dcts::node::detection::ThresholdType value) {
  active_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.EnergyDetectionParam.active_types)
}
inline void EnergyDetectionParam::_internal_add_active_types(::zb::dcts::node::detection::ThresholdType value) {
  active_types_.Add(value);
}
inline void EnergyDetectionParam::add_active_types(::zb::dcts::node::detection::ThresholdType value) {
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.EnergyDetectionParam.active_types)
  _internal_add_active_types(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
EnergyDetectionParam::active_types() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.EnergyDetectionParam.active_types)
  return active_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EnergyDetectionParam::_internal_mutable_active_types() {
  return &active_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
EnergyDetectionParam::mutable_active_types() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.EnergyDetectionParam.active_types)
  return _internal_mutable_active_types();
}

// .zb.dcts.node.detection.EnergyDetectionParam.LogicType logic = 3;
inline void EnergyDetectionParam::clear_logic() {
  logic_ = 0;
}
inline ::zb::dcts::node::detection::EnergyDetectionParam_LogicType EnergyDetectionParam::_internal_logic() const {
  return static_cast< ::zb::dcts::node::detection::EnergyDetectionParam_LogicType >(logic_);
}
inline ::zb::dcts::node::detection::EnergyDetectionParam_LogicType EnergyDetectionParam::logic() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.EnergyDetectionParam.logic)
  return _internal_logic();
}
inline void EnergyDetectionParam::_internal_set_logic(::zb::dcts::node::detection::EnergyDetectionParam_LogicType value) {
  
  logic_ = value;
}
inline void EnergyDetectionParam::set_logic(::zb::dcts::node::detection::EnergyDetectionParam_LogicType value) {
  _internal_set_logic(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.EnergyDetectionParam.logic)
}

// .zb.dcts.node.detection.HistoryThresholdParam history_threshold = 5;
inline bool EnergyDetectionParam::_internal_has_history_threshold() const {
  return this != internal_default_instance() && history_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_history_threshold() const {
  return _internal_has_history_threshold();
}
inline void EnergyDetectionParam::clear_history_threshold() {
  if (GetArena() == nullptr && history_threshold_ != nullptr) {
    delete history_threshold_;
  }
  history_threshold_ = nullptr;
}
inline const ::zb::dcts::node::detection::HistoryThresholdParam& EnergyDetectionParam::_internal_history_threshold() const {
  const ::zb::dcts::node::detection::HistoryThresholdParam* p = history_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::HistoryThresholdParam&>(
      ::zb::dcts::node::detection::_HistoryThresholdParam_default_instance_);
}
inline const ::zb::dcts::node::detection::HistoryThresholdParam& EnergyDetectionParam::history_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.EnergyDetectionParam.history_threshold)
  return _internal_history_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_history_threshold(
    ::zb::dcts::node::detection::HistoryThresholdParam* history_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(history_threshold_);
  }
  history_threshold_ = history_threshold;
  if (history_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.history_threshold)
}
inline ::zb::dcts::node::detection::HistoryThresholdParam* EnergyDetectionParam::release_history_threshold() {
  
  ::zb::dcts::node::detection::HistoryThresholdParam* temp = history_threshold_;
  history_threshold_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::HistoryThresholdParam* EnergyDetectionParam::unsafe_arena_release_history_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.EnergyDetectionParam.history_threshold)
  
  ::zb::dcts::node::detection::HistoryThresholdParam* temp = history_threshold_;
  history_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::HistoryThresholdParam* EnergyDetectionParam::_internal_mutable_history_threshold() {
  
  if (history_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::HistoryThresholdParam>(GetArena());
    history_threshold_ = p;
  }
  return history_threshold_;
}
inline ::zb::dcts::node::detection::HistoryThresholdParam* EnergyDetectionParam::mutable_history_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.EnergyDetectionParam.history_threshold)
  return _internal_mutable_history_threshold();
}
inline void EnergyDetectionParam::set_allocated_history_threshold(::zb::dcts::node::detection::HistoryThresholdParam* history_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete history_threshold_;
  }
  if (history_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(history_threshold);
    if (message_arena != submessage_arena) {
      history_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, history_threshold, submessage_arena);
    }
    
  } else {
    
  }
  history_threshold_ = history_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.history_threshold)
}

// .zb.dcts.node.detection.UserThresholdParam user_threshold = 6;
inline bool EnergyDetectionParam::_internal_has_user_threshold() const {
  return this != internal_default_instance() && user_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_user_threshold() const {
  return _internal_has_user_threshold();
}
inline void EnergyDetectionParam::clear_user_threshold() {
  if (GetArena() == nullptr && user_threshold_ != nullptr) {
    delete user_threshold_;
  }
  user_threshold_ = nullptr;
}
inline const ::zb::dcts::node::detection::UserThresholdParam& EnergyDetectionParam::_internal_user_threshold() const {
  const ::zb::dcts::node::detection::UserThresholdParam* p = user_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::UserThresholdParam&>(
      ::zb::dcts::node::detection::_UserThresholdParam_default_instance_);
}
inline const ::zb::dcts::node::detection::UserThresholdParam& EnergyDetectionParam::user_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.EnergyDetectionParam.user_threshold)
  return _internal_user_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_user_threshold(
    ::zb::dcts::node::detection::UserThresholdParam* user_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_threshold_);
  }
  user_threshold_ = user_threshold;
  if (user_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.user_threshold)
}
inline ::zb::dcts::node::detection::UserThresholdParam* EnergyDetectionParam::release_user_threshold() {
  
  ::zb::dcts::node::detection::UserThresholdParam* temp = user_threshold_;
  user_threshold_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::UserThresholdParam* EnergyDetectionParam::unsafe_arena_release_user_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.EnergyDetectionParam.user_threshold)
  
  ::zb::dcts::node::detection::UserThresholdParam* temp = user_threshold_;
  user_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::UserThresholdParam* EnergyDetectionParam::_internal_mutable_user_threshold() {
  
  if (user_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::UserThresholdParam>(GetArena());
    user_threshold_ = p;
  }
  return user_threshold_;
}
inline ::zb::dcts::node::detection::UserThresholdParam* EnergyDetectionParam::mutable_user_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.EnergyDetectionParam.user_threshold)
  return _internal_mutable_user_threshold();
}
inline void EnergyDetectionParam::set_allocated_user_threshold(::zb::dcts::node::detection::UserThresholdParam* user_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete user_threshold_;
  }
  if (user_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(user_threshold);
    if (message_arena != submessage_arena) {
      user_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_threshold, submessage_arena);
    }
    
  } else {
    
  }
  user_threshold_ = user_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.user_threshold)
}

// .zb.dcts.node.detection.AdaptiveThresholdParam adaptive_threshold = 7;
inline bool EnergyDetectionParam::_internal_has_adaptive_threshold() const {
  return this != internal_default_instance() && adaptive_threshold_ != nullptr;
}
inline bool EnergyDetectionParam::has_adaptive_threshold() const {
  return _internal_has_adaptive_threshold();
}
inline void EnergyDetectionParam::clear_adaptive_threshold() {
  if (GetArena() == nullptr && adaptive_threshold_ != nullptr) {
    delete adaptive_threshold_;
  }
  adaptive_threshold_ = nullptr;
}
inline const ::zb::dcts::node::detection::AdaptiveThresholdParam& EnergyDetectionParam::_internal_adaptive_threshold() const {
  const ::zb::dcts::node::detection::AdaptiveThresholdParam* p = adaptive_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::AdaptiveThresholdParam&>(
      ::zb::dcts::node::detection::_AdaptiveThresholdParam_default_instance_);
}
inline const ::zb::dcts::node::detection::AdaptiveThresholdParam& EnergyDetectionParam::adaptive_threshold() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.EnergyDetectionParam.adaptive_threshold)
  return _internal_adaptive_threshold();
}
inline void EnergyDetectionParam::unsafe_arena_set_allocated_adaptive_threshold(
    ::zb::dcts::node::detection::AdaptiveThresholdParam* adaptive_threshold) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(adaptive_threshold_);
  }
  adaptive_threshold_ = adaptive_threshold;
  if (adaptive_threshold) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.adaptive_threshold)
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam* EnergyDetectionParam::release_adaptive_threshold() {
  
  ::zb::dcts::node::detection::AdaptiveThresholdParam* temp = adaptive_threshold_;
  adaptive_threshold_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam* EnergyDetectionParam::unsafe_arena_release_adaptive_threshold() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.EnergyDetectionParam.adaptive_threshold)
  
  ::zb::dcts::node::detection::AdaptiveThresholdParam* temp = adaptive_threshold_;
  adaptive_threshold_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam* EnergyDetectionParam::_internal_mutable_adaptive_threshold() {
  
  if (adaptive_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::AdaptiveThresholdParam>(GetArena());
    adaptive_threshold_ = p;
  }
  return adaptive_threshold_;
}
inline ::zb::dcts::node::detection::AdaptiveThresholdParam* EnergyDetectionParam::mutable_adaptive_threshold() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.EnergyDetectionParam.adaptive_threshold)
  return _internal_mutable_adaptive_threshold();
}
inline void EnergyDetectionParam::set_allocated_adaptive_threshold(::zb::dcts::node::detection::AdaptiveThresholdParam* adaptive_threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete adaptive_threshold_;
  }
  if (adaptive_threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(adaptive_threshold);
    if (message_arena != submessage_arena) {
      adaptive_threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, adaptive_threshold, submessage_arena);
    }
    
  } else {
    
  }
  adaptive_threshold_ = adaptive_threshold;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.EnergyDetectionParam.adaptive_threshold)
}

// -------------------------------------------------------------------

// ThresholdRefLine

// .zb.dcts.node.detection.ThresholdType type = 1;
inline void ThresholdRefLine::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::node::detection::ThresholdType ThresholdRefLine::_internal_type() const {
  return static_cast< ::zb::dcts::node::detection::ThresholdType >(type_);
}
inline ::zb::dcts::node::detection::ThresholdType ThresholdRefLine::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.ThresholdRefLine.type)
  return _internal_type();
}
inline void ThresholdRefLine::_internal_set_type(::zb::dcts::node::detection::ThresholdType value) {
  
  type_ = value;
}
inline void ThresholdRefLine::set_type(::zb::dcts::node::detection::ThresholdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.ThresholdRefLine.type)
}

// repeated float threshold_trace = 2;
inline int ThresholdRefLine::_internal_threshold_trace_size() const {
  return threshold_trace_.size();
}
inline int ThresholdRefLine::threshold_trace_size() const {
  return _internal_threshold_trace_size();
}
inline void ThresholdRefLine::clear_threshold_trace() {
  threshold_trace_.Clear();
}
inline float ThresholdRefLine::_internal_threshold_trace(int index) const {
  return threshold_trace_.Get(index);
}
inline float ThresholdRefLine::threshold_trace(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.ThresholdRefLine.threshold_trace)
  return _internal_threshold_trace(index);
}
inline void ThresholdRefLine::set_threshold_trace(int index, float value) {
  threshold_trace_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.ThresholdRefLine.threshold_trace)
}
inline void ThresholdRefLine::_internal_add_threshold_trace(float value) {
  threshold_trace_.Add(value);
}
inline void ThresholdRefLine::add_threshold_trace(float value) {
  _internal_add_threshold_trace(value);
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.ThresholdRefLine.threshold_trace)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ThresholdRefLine::_internal_threshold_trace() const {
  return threshold_trace_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ThresholdRefLine::threshold_trace() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.ThresholdRefLine.threshold_trace)
  return _internal_threshold_trace();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ThresholdRefLine::_internal_mutable_threshold_trace() {
  return &threshold_trace_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ThresholdRefLine::mutable_threshold_trace() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.ThresholdRefLine.threshold_trace)
  return _internal_mutable_threshold_trace();
}

// -------------------------------------------------------------------

// SignalFeature

// .zb.dcts.TimeSpan time_span = 1;
inline bool SignalFeature::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool SignalFeature::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& SignalFeature::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TimeSpan&>(
      ::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& SignalFeature::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.time_span)
  return _internal_time_span();
}
inline void SignalFeature::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalFeature.time_span)
}
inline ::zb::dcts::TimeSpan* SignalFeature::release_time_span() {
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalFeature::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalFeature.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalFeature::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* SignalFeature::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalFeature.time_span)
  return _internal_mutable_time_span();
}
inline void SignalFeature::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalFeature.time_span)
}

// .zb.dcts.node.spectrum.SignalBand signal_band = 2;
inline bool SignalFeature::_internal_has_signal_band() const {
  return this != internal_default_instance() && signal_band_ != nullptr;
}
inline bool SignalFeature::has_signal_band() const {
  return _internal_has_signal_band();
}
inline const ::zb::dcts::node::spectrum::SignalBand& SignalFeature::_internal_signal_band() const {
  const ::zb::dcts::node::spectrum::SignalBand* p = signal_band_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::spectrum::SignalBand&>(
      ::zb::dcts::node::spectrum::_SignalBand_default_instance_);
}
inline const ::zb::dcts::node::spectrum::SignalBand& SignalFeature::signal_band() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.signal_band)
  return _internal_signal_band();
}
inline void SignalFeature::unsafe_arena_set_allocated_signal_band(
    ::zb::dcts::node::spectrum::SignalBand* signal_band) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band_);
  }
  signal_band_ = signal_band;
  if (signal_band) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalFeature.signal_band)
}
inline ::zb::dcts::node::spectrum::SignalBand* SignalFeature::release_signal_band() {
  
  ::zb::dcts::node::spectrum::SignalBand* temp = signal_band_;
  signal_band_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::spectrum::SignalBand* SignalFeature::unsafe_arena_release_signal_band() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalFeature.signal_band)
  
  ::zb::dcts::node::spectrum::SignalBand* temp = signal_band_;
  signal_band_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::spectrum::SignalBand* SignalFeature::_internal_mutable_signal_band() {
  
  if (signal_band_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::spectrum::SignalBand>(GetArena());
    signal_band_ = p;
  }
  return signal_band_;
}
inline ::zb::dcts::node::spectrum::SignalBand* SignalFeature::mutable_signal_band() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalFeature.signal_band)
  return _internal_mutable_signal_band();
}
inline void SignalFeature::set_allocated_signal_band(::zb::dcts::node::spectrum::SignalBand* signal_band) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band_);
  }
  if (signal_band) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_band)->GetArena();
    if (message_arena != submessage_arena) {
      signal_band = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_band, submessage_arena);
    }
    
  } else {
    
  }
  signal_band_ = signal_band;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalFeature.signal_band)
}

// int32 num_sweep = 3;
inline void SignalFeature::clear_num_sweep() {
  num_sweep_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalFeature::_internal_num_sweep() const {
  return num_sweep_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalFeature::num_sweep() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.num_sweep)
  return _internal_num_sweep();
}
inline void SignalFeature::_internal_set_num_sweep(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_sweep_ = value;
}
inline void SignalFeature::set_num_sweep(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_sweep(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalFeature.num_sweep)
}

// .zb.dcts.StatisticVal amplitude = 4;
inline bool SignalFeature::_internal_has_amplitude() const {
  return this != internal_default_instance() && amplitude_ != nullptr;
}
inline bool SignalFeature::has_amplitude() const {
  return _internal_has_amplitude();
}
inline const ::zb::dcts::StatisticVal& SignalFeature::_internal_amplitude() const {
  const ::zb::dcts::StatisticVal* p = amplitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::StatisticVal&>(
      ::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalFeature::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.amplitude)
  return _internal_amplitude();
}
inline void SignalFeature::unsafe_arena_set_allocated_amplitude(
    ::zb::dcts::StatisticVal* amplitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  amplitude_ = amplitude;
  if (amplitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalFeature.amplitude)
}
inline ::zb::dcts::StatisticVal* SignalFeature::release_amplitude() {
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::unsafe_arena_release_amplitude() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalFeature.amplitude)
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::_internal_mutable_amplitude() {
  
  if (amplitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    amplitude_ = p;
  }
  return amplitude_;
}
inline ::zb::dcts::StatisticVal* SignalFeature::mutable_amplitude() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalFeature.amplitude)
  return _internal_mutable_amplitude();
}
inline void SignalFeature::set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  if (amplitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude)->GetArena();
    if (message_arena != submessage_arena) {
      amplitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplitude, submessage_arena);
    }
    
  } else {
    
  }
  amplitude_ = amplitude;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalFeature.amplitude)
}

// .zb.dcts.StatisticVal hits = 5;
inline bool SignalFeature::_internal_has_hits() const {
  return this != internal_default_instance() && hits_ != nullptr;
}
inline bool SignalFeature::has_hits() const {
  return _internal_has_hits();
}
inline const ::zb::dcts::StatisticVal& SignalFeature::_internal_hits() const {
  const ::zb::dcts::StatisticVal* p = hits_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::StatisticVal&>(
      ::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalFeature::hits() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.hits)
  return _internal_hits();
}
inline void SignalFeature::unsafe_arena_set_allocated_hits(
    ::zb::dcts::StatisticVal* hits) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits_);
  }
  hits_ = hits;
  if (hits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalFeature.hits)
}
inline ::zb::dcts::StatisticVal* SignalFeature::release_hits() {
  
  ::zb::dcts::StatisticVal* temp = hits_;
  hits_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::unsafe_arena_release_hits() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalFeature.hits)
  
  ::zb::dcts::StatisticVal* temp = hits_;
  hits_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalFeature::_internal_mutable_hits() {
  
  if (hits_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    hits_ = p;
  }
  return hits_;
}
inline ::zb::dcts::StatisticVal* SignalFeature::mutable_hits() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalFeature.hits)
  return _internal_mutable_hits();
}
inline void SignalFeature::set_allocated_hits(::zb::dcts::StatisticVal* hits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits_);
  }
  if (hits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits)->GetArena();
    if (message_arena != submessage_arena) {
      hits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hits, submessage_arena);
    }
    
  } else {
    
  }
  hits_ = hits;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalFeature.hits)
}

// repeated float spectrum_detail = 8;
inline int SignalFeature::_internal_spectrum_detail_size() const {
  return spectrum_detail_.size();
}
inline int SignalFeature::spectrum_detail_size() const {
  return _internal_spectrum_detail_size();
}
inline void SignalFeature::clear_spectrum_detail() {
  spectrum_detail_.Clear();
}
inline float SignalFeature::_internal_spectrum_detail(int index) const {
  return spectrum_detail_.Get(index);
}
inline float SignalFeature::spectrum_detail(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.spectrum_detail)
  return _internal_spectrum_detail(index);
}
inline void SignalFeature::set_spectrum_detail(int index, float value) {
  spectrum_detail_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalFeature.spectrum_detail)
}
inline void SignalFeature::_internal_add_spectrum_detail(float value) {
  spectrum_detail_.Add(value);
}
inline void SignalFeature::add_spectrum_detail(float value) {
  _internal_add_spectrum_detail(value);
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalFeature.spectrum_detail)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SignalFeature::_internal_spectrum_detail() const {
  return spectrum_detail_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SignalFeature::spectrum_detail() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.SignalFeature.spectrum_detail)
  return _internal_spectrum_detail();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SignalFeature::_internal_mutable_spectrum_detail() {
  return &spectrum_detail_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SignalFeature::mutable_spectrum_detail() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.SignalFeature.spectrum_detail)
  return _internal_mutable_spectrum_detail();
}

// repeated float hits_detail = 9;
inline int SignalFeature::_internal_hits_detail_size() const {
  return hits_detail_.size();
}
inline int SignalFeature::hits_detail_size() const {
  return _internal_hits_detail_size();
}
inline void SignalFeature::clear_hits_detail() {
  hits_detail_.Clear();
}
inline float SignalFeature::_internal_hits_detail(int index) const {
  return hits_detail_.Get(index);
}
inline float SignalFeature::hits_detail(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalFeature.hits_detail)
  return _internal_hits_detail(index);
}
inline void SignalFeature::set_hits_detail(int index, float value) {
  hits_detail_.Set(index, value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalFeature.hits_detail)
}
inline void SignalFeature::_internal_add_hits_detail(float value) {
  hits_detail_.Add(value);
}
inline void SignalFeature::add_hits_detail(float value) {
  _internal_add_hits_detail(value);
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalFeature.hits_detail)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SignalFeature::_internal_hits_detail() const {
  return hits_detail_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SignalFeature::hits_detail() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.SignalFeature.hits_detail)
  return _internal_hits_detail();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SignalFeature::_internal_mutable_hits_detail() {
  return &hits_detail_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SignalFeature::mutable_hits_detail() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.SignalFeature.hits_detail)
  return _internal_mutable_hits_detail();
}

// -------------------------------------------------------------------

// SignalSegment

// string id = 1;
inline void SignalSegment::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SignalSegment::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.id)
  return _internal_id();
}
inline void SignalSegment::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalSegment.id)
}
inline std::string* SignalSegment::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.id)
  return _internal_mutable_id();
}
inline const std::string& SignalSegment::_internal_id() const {
  return id_.Get();
}
inline void SignalSegment::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SignalSegment::set_id(std::string&& value) {
  
  id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.node.detection.SignalSegment.id)
}
inline void SignalSegment::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.node.detection.SignalSegment.id)
}
inline void SignalSegment::set_id(const char* value,
    size_t size) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.node.detection.SignalSegment.id)
}
inline std::string* SignalSegment::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SignalSegment::release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalSegment.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignalSegment::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalSegment.id)
}

// int32 segment_seq = 2;
inline void SignalSegment::clear_segment_seq() {
  segment_seq_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::_internal_segment_seq() const {
  return segment_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::segment_seq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.segment_seq)
  return _internal_segment_seq();
}
inline void SignalSegment::_internal_set_segment_seq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  segment_seq_ = value;
}
inline void SignalSegment::set_segment_seq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_segment_seq(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalSegment.segment_seq)
}

// .zb.dcts.StatisticVal center_freq = 3;
inline bool SignalSegment::_internal_has_center_freq() const {
  return this != internal_default_instance() && center_freq_ != nullptr;
}
inline bool SignalSegment::has_center_freq() const {
  return _internal_has_center_freq();
}
inline const ::zb::dcts::StatisticVal& SignalSegment::_internal_center_freq() const {
  const ::zb::dcts::StatisticVal* p = center_freq_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::StatisticVal&>(
      ::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalSegment::center_freq() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.center_freq)
  return _internal_center_freq();
}
inline void SignalSegment::unsafe_arena_set_allocated_center_freq(
    ::zb::dcts::StatisticVal* center_freq) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  center_freq_ = center_freq;
  if (center_freq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalSegment.center_freq)
}
inline ::zb::dcts::StatisticVal* SignalSegment::release_center_freq() {
  
  ::zb::dcts::StatisticVal* temp = center_freq_;
  center_freq_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::unsafe_arena_release_center_freq() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalSegment.center_freq)
  
  ::zb::dcts::StatisticVal* temp = center_freq_;
  center_freq_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::_internal_mutable_center_freq() {
  
  if (center_freq_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    center_freq_ = p;
  }
  return center_freq_;
}
inline ::zb::dcts::StatisticVal* SignalSegment::mutable_center_freq() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.center_freq)
  return _internal_mutable_center_freq();
}
inline void SignalSegment::set_allocated_center_freq(::zb::dcts::StatisticVal* center_freq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq_);
  }
  if (center_freq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_freq)->GetArena();
    if (message_arena != submessage_arena) {
      center_freq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center_freq, submessage_arena);
    }
    
  } else {
    
  }
  center_freq_ = center_freq;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalSegment.center_freq)
}

// .zb.dcts.StatisticVal band_width = 4;
inline bool SignalSegment::_internal_has_band_width() const {
  return this != internal_default_instance() && band_width_ != nullptr;
}
inline bool SignalSegment::has_band_width() const {
  return _internal_has_band_width();
}
inline const ::zb::dcts::StatisticVal& SignalSegment::_internal_band_width() const {
  const ::zb::dcts::StatisticVal* p = band_width_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::StatisticVal&>(
      ::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalSegment::band_width() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.band_width)
  return _internal_band_width();
}
inline void SignalSegment::unsafe_arena_set_allocated_band_width(
    ::zb::dcts::StatisticVal* band_width) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  band_width_ = band_width;
  if (band_width) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalSegment.band_width)
}
inline ::zb::dcts::StatisticVal* SignalSegment::release_band_width() {
  
  ::zb::dcts::StatisticVal* temp = band_width_;
  band_width_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::unsafe_arena_release_band_width() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalSegment.band_width)
  
  ::zb::dcts::StatisticVal* temp = band_width_;
  band_width_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::_internal_mutable_band_width() {
  
  if (band_width_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    band_width_ = p;
  }
  return band_width_;
}
inline ::zb::dcts::StatisticVal* SignalSegment::mutable_band_width() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.band_width)
  return _internal_mutable_band_width();
}
inline void SignalSegment::set_allocated_band_width(::zb::dcts::StatisticVal* band_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width_);
  }
  if (band_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(band_width)->GetArena();
    if (message_arena != submessage_arena) {
      band_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, band_width, submessage_arena);
    }
    
  } else {
    
  }
  band_width_ = band_width;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalSegment.band_width)
}

// .zb.dcts.StatisticVal amplitude = 5;
inline bool SignalSegment::_internal_has_amplitude() const {
  return this != internal_default_instance() && amplitude_ != nullptr;
}
inline bool SignalSegment::has_amplitude() const {
  return _internal_has_amplitude();
}
inline const ::zb::dcts::StatisticVal& SignalSegment::_internal_amplitude() const {
  const ::zb::dcts::StatisticVal* p = amplitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::StatisticVal&>(
      ::zb::dcts::_StatisticVal_default_instance_);
}
inline const ::zb::dcts::StatisticVal& SignalSegment::amplitude() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.amplitude)
  return _internal_amplitude();
}
inline void SignalSegment::unsafe_arena_set_allocated_amplitude(
    ::zb::dcts::StatisticVal* amplitude) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  amplitude_ = amplitude;
  if (amplitude) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalSegment.amplitude)
}
inline ::zb::dcts::StatisticVal* SignalSegment::release_amplitude() {
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::unsafe_arena_release_amplitude() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalSegment.amplitude)
  
  ::zb::dcts::StatisticVal* temp = amplitude_;
  amplitude_ = nullptr;
  return temp;
}
inline ::zb::dcts::StatisticVal* SignalSegment::_internal_mutable_amplitude() {
  
  if (amplitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::StatisticVal>(GetArena());
    amplitude_ = p;
  }
  return amplitude_;
}
inline ::zb::dcts::StatisticVal* SignalSegment::mutable_amplitude() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.amplitude)
  return _internal_mutable_amplitude();
}
inline void SignalSegment::set_allocated_amplitude(::zb::dcts::StatisticVal* amplitude) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude_);
  }
  if (amplitude) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amplitude)->GetArena();
    if (message_arena != submessage_arena) {
      amplitude = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amplitude, submessage_arena);
    }
    
  } else {
    
  }
  amplitude_ = amplitude;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalSegment.amplitude)
}

// .zb.dcts.TimeSpan time_span = 6;
inline bool SignalSegment::_internal_has_time_span() const {
  return this != internal_default_instance() && time_span_ != nullptr;
}
inline bool SignalSegment::has_time_span() const {
  return _internal_has_time_span();
}
inline const ::zb::dcts::TimeSpan& SignalSegment::_internal_time_span() const {
  const ::zb::dcts::TimeSpan* p = time_span_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TimeSpan&>(
      ::zb::dcts::_TimeSpan_default_instance_);
}
inline const ::zb::dcts::TimeSpan& SignalSegment::time_span() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.time_span)
  return _internal_time_span();
}
inline void SignalSegment::unsafe_arena_set_allocated_time_span(
    ::zb::dcts::TimeSpan* time_span) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  time_span_ = time_span;
  if (time_span) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SignalSegment.time_span)
}
inline ::zb::dcts::TimeSpan* SignalSegment::release_time_span() {
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalSegment::unsafe_arena_release_time_span() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SignalSegment.time_span)
  
  ::zb::dcts::TimeSpan* temp = time_span_;
  time_span_ = nullptr;
  return temp;
}
inline ::zb::dcts::TimeSpan* SignalSegment::_internal_mutable_time_span() {
  
  if (time_span_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TimeSpan>(GetArena());
    time_span_ = p;
  }
  return time_span_;
}
inline ::zb::dcts::TimeSpan* SignalSegment::mutable_time_span() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.time_span)
  return _internal_mutable_time_span();
}
inline void SignalSegment::set_allocated_time_span(::zb::dcts::TimeSpan* time_span) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span_);
  }
  if (time_span) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_span)->GetArena();
    if (message_arena != submessage_arena) {
      time_span = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_span, submessage_arena);
    }
    
  } else {
    
  }
  time_span_ = time_span;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SignalSegment.time_span)
}

// int32 total_sweep = 7;
inline void SignalSegment::clear_total_sweep() {
  total_sweep_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::_internal_total_sweep() const {
  return total_sweep_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::total_sweep() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.total_sweep)
  return _internal_total_sweep();
}
inline void SignalSegment::_internal_set_total_sweep(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  total_sweep_ = value;
}
inline void SignalSegment::set_total_sweep(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_sweep(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalSegment.total_sweep)
}

// int32 total_hits = 8;
inline void SignalSegment::clear_total_hits() {
  total_hits_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::_internal_total_hits() const {
  return total_hits_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignalSegment::total_hits() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.total_hits)
  return _internal_total_hits();
}
inline void SignalSegment::_internal_set_total_hits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  total_hits_ = value;
}
inline void SignalSegment::set_total_hits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_hits(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalSegment.total_hits)
}

// repeated .zb.dcts.node.detection.SignalFeature feature = 9;
inline int SignalSegment::_internal_feature_size() const {
  return feature_.size();
}
inline int SignalSegment::feature_size() const {
  return _internal_feature_size();
}
inline void SignalSegment::clear_feature() {
  feature_.Clear();
}
inline ::zb::dcts::node::detection::SignalFeature* SignalSegment::mutable_feature(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalSegment.feature)
  return feature_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalFeature >*
SignalSegment::mutable_feature() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.SignalSegment.feature)
  return &feature_;
}
inline const ::zb::dcts::node::detection::SignalFeature& SignalSegment::_internal_feature(int index) const {
  return feature_.Get(index);
}
inline const ::zb::dcts::node::detection::SignalFeature& SignalSegment::feature(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalSegment.feature)
  return _internal_feature(index);
}
inline ::zb::dcts::node::detection::SignalFeature* SignalSegment::_internal_add_feature() {
  return feature_.Add();
}
inline ::zb::dcts::node::detection::SignalFeature* SignalSegment::add_feature() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalSegment.feature)
  return _internal_add_feature();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalFeature >&
SignalSegment::feature() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.SignalSegment.feature)
  return feature_;
}

// -------------------------------------------------------------------

// HitsSegmentation

// repeated .zb.dcts.DRange hits_prob = 1;
inline int HitsSegmentation::_internal_hits_prob_size() const {
  return hits_prob_.size();
}
inline int HitsSegmentation::hits_prob_size() const {
  return _internal_hits_prob_size();
}
inline ::zb::dcts::DRange* HitsSegmentation::mutable_hits_prob(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.HitsSegmentation.hits_prob)
  return hits_prob_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::DRange >*
HitsSegmentation::mutable_hits_prob() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.HitsSegmentation.hits_prob)
  return &hits_prob_;
}
inline const ::zb::dcts::DRange& HitsSegmentation::_internal_hits_prob(int index) const {
  return hits_prob_.Get(index);
}
inline const ::zb::dcts::DRange& HitsSegmentation::hits_prob(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.HitsSegmentation.hits_prob)
  return _internal_hits_prob(index);
}
inline ::zb::dcts::DRange* HitsSegmentation::_internal_add_hits_prob() {
  return hits_prob_.Add();
}
inline ::zb::dcts::DRange* HitsSegmentation::add_hits_prob() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.HitsSegmentation.hits_prob)
  return _internal_add_hits_prob();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::DRange >&
HitsSegmentation::hits_prob() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.HitsSegmentation.hits_prob)
  return hits_prob_;
}

// .zb.dcts.DRange bandwidth_range = 2;
inline bool HitsSegmentation::_internal_has_bandwidth_range() const {
  return this != internal_default_instance() && bandwidth_range_ != nullptr;
}
inline bool HitsSegmentation::has_bandwidth_range() const {
  return _internal_has_bandwidth_range();
}
inline const ::zb::dcts::DRange& HitsSegmentation::_internal_bandwidth_range() const {
  const ::zb::dcts::DRange* p = bandwidth_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::DRange&>(
      ::zb::dcts::_DRange_default_instance_);
}
inline const ::zb::dcts::DRange& HitsSegmentation::bandwidth_range() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.HitsSegmentation.bandwidth_range)
  return _internal_bandwidth_range();
}
inline void HitsSegmentation::unsafe_arena_set_allocated_bandwidth_range(
    ::zb::dcts::DRange* bandwidth_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bandwidth_range_);
  }
  bandwidth_range_ = bandwidth_range;
  if (bandwidth_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.HitsSegmentation.bandwidth_range)
}
inline ::zb::dcts::DRange* HitsSegmentation::release_bandwidth_range() {
  
  ::zb::dcts::DRange* temp = bandwidth_range_;
  bandwidth_range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::DRange* HitsSegmentation::unsafe_arena_release_bandwidth_range() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.HitsSegmentation.bandwidth_range)
  
  ::zb::dcts::DRange* temp = bandwidth_range_;
  bandwidth_range_ = nullptr;
  return temp;
}
inline ::zb::dcts::DRange* HitsSegmentation::_internal_mutable_bandwidth_range() {
  
  if (bandwidth_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::DRange>(GetArena());
    bandwidth_range_ = p;
  }
  return bandwidth_range_;
}
inline ::zb::dcts::DRange* HitsSegmentation::mutable_bandwidth_range() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.HitsSegmentation.bandwidth_range)
  return _internal_mutable_bandwidth_range();
}
inline void HitsSegmentation::set_allocated_bandwidth_range(::zb::dcts::DRange* bandwidth_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bandwidth_range_);
  }
  if (bandwidth_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bandwidth_range)->GetArena();
    if (message_arena != submessage_arena) {
      bandwidth_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bandwidth_range, submessage_arena);
    }
    
  } else {
    
  }
  bandwidth_range_ = bandwidth_range;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.HitsSegmentation.bandwidth_range)
}

// -------------------------------------------------------------------

// SegmentationParam

// uint32 enable_filters = 1;
inline void SegmentationParam::clear_enable_filters() {
  enable_filters_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SegmentationParam::_internal_enable_filters() const {
  return enable_filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SegmentationParam::enable_filters() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SegmentationParam.enable_filters)
  return _internal_enable_filters();
}
inline void SegmentationParam::_internal_set_enable_filters(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  enable_filters_ = value;
}
inline void SegmentationParam::set_enable_filters(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_enable_filters(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SegmentationParam.enable_filters)
}

// int32 num_overlap = 2;
inline void SegmentationParam::clear_num_overlap() {
  num_overlap_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SegmentationParam::_internal_num_overlap() const {
  return num_overlap_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SegmentationParam::num_overlap() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SegmentationParam.num_overlap)
  return _internal_num_overlap();
}
inline void SegmentationParam::_internal_set_num_overlap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_overlap_ = value;
}
inline void SegmentationParam::set_num_overlap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_overlap(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SegmentationParam.num_overlap)
}

// .zb.dcts.node.detection.HitsSegmentation hits_param = 3;
inline bool SegmentationParam::_internal_has_hits_param() const {
  return this != internal_default_instance() && hits_param_ != nullptr;
}
inline bool SegmentationParam::has_hits_param() const {
  return _internal_has_hits_param();
}
inline void SegmentationParam::clear_hits_param() {
  if (GetArena() == nullptr && hits_param_ != nullptr) {
    delete hits_param_;
  }
  hits_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::HitsSegmentation& SegmentationParam::_internal_hits_param() const {
  const ::zb::dcts::node::detection::HitsSegmentation* p = hits_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::HitsSegmentation&>(
      ::zb::dcts::node::detection::_HitsSegmentation_default_instance_);
}
inline const ::zb::dcts::node::detection::HitsSegmentation& SegmentationParam::hits_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SegmentationParam.hits_param)
  return _internal_hits_param();
}
inline void SegmentationParam::unsafe_arena_set_allocated_hits_param(
    ::zb::dcts::node::detection::HitsSegmentation* hits_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hits_param_);
  }
  hits_param_ = hits_param;
  if (hits_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.SegmentationParam.hits_param)
}
inline ::zb::dcts::node::detection::HitsSegmentation* SegmentationParam::release_hits_param() {
  
  ::zb::dcts::node::detection::HitsSegmentation* temp = hits_param_;
  hits_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::HitsSegmentation* SegmentationParam::unsafe_arena_release_hits_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.SegmentationParam.hits_param)
  
  ::zb::dcts::node::detection::HitsSegmentation* temp = hits_param_;
  hits_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::HitsSegmentation* SegmentationParam::_internal_mutable_hits_param() {
  
  if (hits_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::HitsSegmentation>(GetArena());
    hits_param_ = p;
  }
  return hits_param_;
}
inline ::zb::dcts::node::detection::HitsSegmentation* SegmentationParam::mutable_hits_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SegmentationParam.hits_param)
  return _internal_mutable_hits_param();
}
inline void SegmentationParam::set_allocated_hits_param(::zb::dcts::node::detection::HitsSegmentation* hits_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hits_param_;
  }
  if (hits_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hits_param);
    if (message_arena != submessage_arena) {
      hits_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hits_param, submessage_arena);
    }
    
  } else {
    
  }
  hits_param_ = hits_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.SegmentationParam.hits_param)
}

// -------------------------------------------------------------------

// SpectrumIntersection

// float min_intersection_ratio = 1;
inline void SpectrumIntersection::clear_min_intersection_ratio() {
  min_intersection_ratio_ = 0;
}
inline float SpectrumIntersection::_internal_min_intersection_ratio() const {
  return min_intersection_ratio_;
}
inline float SpectrumIntersection::min_intersection_ratio() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SpectrumIntersection.min_intersection_ratio)
  return _internal_min_intersection_ratio();
}
inline void SpectrumIntersection::_internal_set_min_intersection_ratio(float value) {
  
  min_intersection_ratio_ = value;
}
inline void SpectrumIntersection::set_min_intersection_ratio(float value) {
  _internal_set_min_intersection_ratio(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SpectrumIntersection.min_intersection_ratio)
}

// int32 max_time_gap = 2;
inline void SpectrumIntersection::clear_max_time_gap() {
  max_time_gap_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpectrumIntersection::_internal_max_time_gap() const {
  return max_time_gap_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpectrumIntersection::max_time_gap() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SpectrumIntersection.max_time_gap)
  return _internal_max_time_gap();
}
inline void SpectrumIntersection::_internal_set_max_time_gap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_time_gap_ = value;
}
inline void SpectrumIntersection::set_max_time_gap(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_time_gap(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SpectrumIntersection.max_time_gap)
}

// -------------------------------------------------------------------

// MergeParam

// .zb.dcts.node.detection.MergePolicy policy = 1;
inline void MergeParam::clear_policy() {
  policy_ = 0;
}
inline ::zb::dcts::node::detection::MergePolicy MergeParam::_internal_policy() const {
  return static_cast< ::zb::dcts::node::detection::MergePolicy >(policy_);
}
inline ::zb::dcts::node::detection::MergePolicy MergeParam::policy() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.MergeParam.policy)
  return _internal_policy();
}
inline void MergeParam::_internal_set_policy(::zb::dcts::node::detection::MergePolicy value) {
  
  policy_ = value;
}
inline void MergeParam::set_policy(::zb::dcts::node::detection::MergePolicy value) {
  _internal_set_policy(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.MergeParam.policy)
}

// .zb.dcts.node.detection.SpectrumIntersection feature_merge_param = 3;
inline bool MergeParam::_internal_has_feature_merge_param() const {
  return this != internal_default_instance() && feature_merge_param_ != nullptr;
}
inline bool MergeParam::has_feature_merge_param() const {
  return _internal_has_feature_merge_param();
}
inline void MergeParam::clear_feature_merge_param() {
  if (GetArena() == nullptr && feature_merge_param_ != nullptr) {
    delete feature_merge_param_;
  }
  feature_merge_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::SpectrumIntersection& MergeParam::_internal_feature_merge_param() const {
  const ::zb::dcts::node::detection::SpectrumIntersection* p = feature_merge_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::SpectrumIntersection&>(
      ::zb::dcts::node::detection::_SpectrumIntersection_default_instance_);
}
inline const ::zb::dcts::node::detection::SpectrumIntersection& MergeParam::feature_merge_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.MergeParam.feature_merge_param)
  return _internal_feature_merge_param();
}
inline void MergeParam::unsafe_arena_set_allocated_feature_merge_param(
    ::zb::dcts::node::detection::SpectrumIntersection* feature_merge_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_merge_param_);
  }
  feature_merge_param_ = feature_merge_param;
  if (feature_merge_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.MergeParam.feature_merge_param)
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::release_feature_merge_param() {
  
  ::zb::dcts::node::detection::SpectrumIntersection* temp = feature_merge_param_;
  feature_merge_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::unsafe_arena_release_feature_merge_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.MergeParam.feature_merge_param)
  
  ::zb::dcts::node::detection::SpectrumIntersection* temp = feature_merge_param_;
  feature_merge_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::_internal_mutable_feature_merge_param() {
  
  if (feature_merge_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::SpectrumIntersection>(GetArena());
    feature_merge_param_ = p;
  }
  return feature_merge_param_;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::mutable_feature_merge_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.MergeParam.feature_merge_param)
  return _internal_mutable_feature_merge_param();
}
inline void MergeParam::set_allocated_feature_merge_param(::zb::dcts::node::detection::SpectrumIntersection* feature_merge_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete feature_merge_param_;
  }
  if (feature_merge_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(feature_merge_param);
    if (message_arena != submessage_arena) {
      feature_merge_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_merge_param, submessage_arena);
    }
    
  } else {
    
  }
  feature_merge_param_ = feature_merge_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.MergeParam.feature_merge_param)
}

// .zb.dcts.node.detection.SpectrumIntersection signal_merge_param = 4;
inline bool MergeParam::_internal_has_signal_merge_param() const {
  return this != internal_default_instance() && signal_merge_param_ != nullptr;
}
inline bool MergeParam::has_signal_merge_param() const {
  return _internal_has_signal_merge_param();
}
inline void MergeParam::clear_signal_merge_param() {
  if (GetArena() == nullptr && signal_merge_param_ != nullptr) {
    delete signal_merge_param_;
  }
  signal_merge_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::SpectrumIntersection& MergeParam::_internal_signal_merge_param() const {
  const ::zb::dcts::node::detection::SpectrumIntersection* p = signal_merge_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::SpectrumIntersection&>(
      ::zb::dcts::node::detection::_SpectrumIntersection_default_instance_);
}
inline const ::zb::dcts::node::detection::SpectrumIntersection& MergeParam::signal_merge_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.MergeParam.signal_merge_param)
  return _internal_signal_merge_param();
}
inline void MergeParam::unsafe_arena_set_allocated_signal_merge_param(
    ::zb::dcts::node::detection::SpectrumIntersection* signal_merge_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signal_merge_param_);
  }
  signal_merge_param_ = signal_merge_param;
  if (signal_merge_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.MergeParam.signal_merge_param)
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::release_signal_merge_param() {
  
  ::zb::dcts::node::detection::SpectrumIntersection* temp = signal_merge_param_;
  signal_merge_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::unsafe_arena_release_signal_merge_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.MergeParam.signal_merge_param)
  
  ::zb::dcts::node::detection::SpectrumIntersection* temp = signal_merge_param_;
  signal_merge_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::_internal_mutable_signal_merge_param() {
  
  if (signal_merge_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::SpectrumIntersection>(GetArena());
    signal_merge_param_ = p;
  }
  return signal_merge_param_;
}
inline ::zb::dcts::node::detection::SpectrumIntersection* MergeParam::mutable_signal_merge_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.MergeParam.signal_merge_param)
  return _internal_mutable_signal_merge_param();
}
inline void MergeParam::set_allocated_signal_merge_param(::zb::dcts::node::detection::SpectrumIntersection* signal_merge_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signal_merge_param_;
  }
  if (signal_merge_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signal_merge_param);
    if (message_arena != submessage_arena) {
      signal_merge_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signal_merge_param, submessage_arena);
    }
    
  } else {
    
  }
  signal_merge_param_ = signal_merge_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.MergeParam.signal_merge_param)
}

// -------------------------------------------------------------------

// DetectionOption

// .zb.dcts.Boolean clear_signal_lib_history = 1;
inline bool DetectionOption::_internal_has_clear_signal_lib_history() const {
  return this != internal_default_instance() && clear_signal_lib_history_ != nullptr;
}
inline bool DetectionOption::has_clear_signal_lib_history() const {
  return _internal_has_clear_signal_lib_history();
}
inline const ::zb::dcts::Boolean& DetectionOption::_internal_clear_signal_lib_history() const {
  const ::zb::dcts::Boolean* p = clear_signal_lib_history_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Boolean&>(
      ::zb::dcts::_Boolean_default_instance_);
}
inline const ::zb::dcts::Boolean& DetectionOption::clear_signal_lib_history() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionOption.clear_signal_lib_history)
  return _internal_clear_signal_lib_history();
}
inline void DetectionOption::unsafe_arena_set_allocated_clear_signal_lib_history(
    ::zb::dcts::Boolean* clear_signal_lib_history) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clear_signal_lib_history_);
  }
  clear_signal_lib_history_ = clear_signal_lib_history;
  if (clear_signal_lib_history) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionOption.clear_signal_lib_history)
}
inline ::zb::dcts::Boolean* DetectionOption::release_clear_signal_lib_history() {
  
  ::zb::dcts::Boolean* temp = clear_signal_lib_history_;
  clear_signal_lib_history_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Boolean* DetectionOption::unsafe_arena_release_clear_signal_lib_history() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionOption.clear_signal_lib_history)
  
  ::zb::dcts::Boolean* temp = clear_signal_lib_history_;
  clear_signal_lib_history_ = nullptr;
  return temp;
}
inline ::zb::dcts::Boolean* DetectionOption::_internal_mutable_clear_signal_lib_history() {
  
  if (clear_signal_lib_history_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Boolean>(GetArena());
    clear_signal_lib_history_ = p;
  }
  return clear_signal_lib_history_;
}
inline ::zb::dcts::Boolean* DetectionOption::mutable_clear_signal_lib_history() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionOption.clear_signal_lib_history)
  return _internal_mutable_clear_signal_lib_history();
}
inline void DetectionOption::set_allocated_clear_signal_lib_history(::zb::dcts::Boolean* clear_signal_lib_history) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(clear_signal_lib_history_);
  }
  if (clear_signal_lib_history) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clear_signal_lib_history)->GetArena();
    if (message_arena != submessage_arena) {
      clear_signal_lib_history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_signal_lib_history, submessage_arena);
    }
    
  } else {
    
  }
  clear_signal_lib_history_ = clear_signal_lib_history;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionOption.clear_signal_lib_history)
}

// .zb.dcts.Integer commit_result_period = 3;
inline bool DetectionOption::_internal_has_commit_result_period() const {
  return this != internal_default_instance() && commit_result_period_ != nullptr;
}
inline bool DetectionOption::has_commit_result_period() const {
  return _internal_has_commit_result_period();
}
inline const ::zb::dcts::Integer& DetectionOption::_internal_commit_result_period() const {
  const ::zb::dcts::Integer* p = commit_result_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Integer&>(
      ::zb::dcts::_Integer_default_instance_);
}
inline const ::zb::dcts::Integer& DetectionOption::commit_result_period() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionOption.commit_result_period)
  return _internal_commit_result_period();
}
inline void DetectionOption::unsafe_arena_set_allocated_commit_result_period(
    ::zb::dcts::Integer* commit_result_period) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_result_period_);
  }
  commit_result_period_ = commit_result_period;
  if (commit_result_period) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionOption.commit_result_period)
}
inline ::zb::dcts::Integer* DetectionOption::release_commit_result_period() {
  
  ::zb::dcts::Integer* temp = commit_result_period_;
  commit_result_period_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Integer* DetectionOption::unsafe_arena_release_commit_result_period() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionOption.commit_result_period)
  
  ::zb::dcts::Integer* temp = commit_result_period_;
  commit_result_period_ = nullptr;
  return temp;
}
inline ::zb::dcts::Integer* DetectionOption::_internal_mutable_commit_result_period() {
  
  if (commit_result_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Integer>(GetArena());
    commit_result_period_ = p;
  }
  return commit_result_period_;
}
inline ::zb::dcts::Integer* DetectionOption::mutable_commit_result_period() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionOption.commit_result_period)
  return _internal_mutable_commit_result_period();
}
inline void DetectionOption::set_allocated_commit_result_period(::zb::dcts::Integer* commit_result_period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_result_period_);
  }
  if (commit_result_period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_result_period)->GetArena();
    if (message_arena != submessage_arena) {
      commit_result_period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit_result_period, submessage_arena);
    }
    
  } else {
    
  }
  commit_result_period_ = commit_result_period;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionOption.commit_result_period)
}

// -------------------------------------------------------------------

// DetectionParam

// .zb.dcts.node.detection.EnergyDetectionParam energy_detect_param = 1;
inline bool DetectionParam::_internal_has_energy_detect_param() const {
  return this != internal_default_instance() && energy_detect_param_ != nullptr;
}
inline bool DetectionParam::has_energy_detect_param() const {
  return _internal_has_energy_detect_param();
}
inline void DetectionParam::clear_energy_detect_param() {
  if (GetArena() == nullptr && energy_detect_param_ != nullptr) {
    delete energy_detect_param_;
  }
  energy_detect_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::EnergyDetectionParam& DetectionParam::_internal_energy_detect_param() const {
  const ::zb::dcts::node::detection::EnergyDetectionParam* p = energy_detect_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::EnergyDetectionParam&>(
      ::zb::dcts::node::detection::_EnergyDetectionParam_default_instance_);
}
inline const ::zb::dcts::node::detection::EnergyDetectionParam& DetectionParam::energy_detect_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionParam.energy_detect_param)
  return _internal_energy_detect_param();
}
inline void DetectionParam::unsafe_arena_set_allocated_energy_detect_param(
    ::zb::dcts::node::detection::EnergyDetectionParam* energy_detect_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(energy_detect_param_);
  }
  energy_detect_param_ = energy_detect_param;
  if (energy_detect_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionParam.energy_detect_param)
}
inline ::zb::dcts::node::detection::EnergyDetectionParam* DetectionParam::release_energy_detect_param() {
  
  ::zb::dcts::node::detection::EnergyDetectionParam* temp = energy_detect_param_;
  energy_detect_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::EnergyDetectionParam* DetectionParam::unsafe_arena_release_energy_detect_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionParam.energy_detect_param)
  
  ::zb::dcts::node::detection::EnergyDetectionParam* temp = energy_detect_param_;
  energy_detect_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::EnergyDetectionParam* DetectionParam::_internal_mutable_energy_detect_param() {
  
  if (energy_detect_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::EnergyDetectionParam>(GetArena());
    energy_detect_param_ = p;
  }
  return energy_detect_param_;
}
inline ::zb::dcts::node::detection::EnergyDetectionParam* DetectionParam::mutable_energy_detect_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionParam.energy_detect_param)
  return _internal_mutable_energy_detect_param();
}
inline void DetectionParam::set_allocated_energy_detect_param(::zb::dcts::node::detection::EnergyDetectionParam* energy_detect_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete energy_detect_param_;
  }
  if (energy_detect_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(energy_detect_param);
    if (message_arena != submessage_arena) {
      energy_detect_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energy_detect_param, submessage_arena);
    }
    
  } else {
    
  }
  energy_detect_param_ = energy_detect_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionParam.energy_detect_param)
}

// .zb.dcts.node.detection.SegmentationParam segmentation_param = 3;
inline bool DetectionParam::_internal_has_segmentation_param() const {
  return this != internal_default_instance() && segmentation_param_ != nullptr;
}
inline bool DetectionParam::has_segmentation_param() const {
  return _internal_has_segmentation_param();
}
inline void DetectionParam::clear_segmentation_param() {
  if (GetArena() == nullptr && segmentation_param_ != nullptr) {
    delete segmentation_param_;
  }
  segmentation_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::SegmentationParam& DetectionParam::_internal_segmentation_param() const {
  const ::zb::dcts::node::detection::SegmentationParam* p = segmentation_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::SegmentationParam&>(
      ::zb::dcts::node::detection::_SegmentationParam_default_instance_);
}
inline const ::zb::dcts::node::detection::SegmentationParam& DetectionParam::segmentation_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionParam.segmentation_param)
  return _internal_segmentation_param();
}
inline void DetectionParam::unsafe_arena_set_allocated_segmentation_param(
    ::zb::dcts::node::detection::SegmentationParam* segmentation_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(segmentation_param_);
  }
  segmentation_param_ = segmentation_param;
  if (segmentation_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionParam.segmentation_param)
}
inline ::zb::dcts::node::detection::SegmentationParam* DetectionParam::release_segmentation_param() {
  
  ::zb::dcts::node::detection::SegmentationParam* temp = segmentation_param_;
  segmentation_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::SegmentationParam* DetectionParam::unsafe_arena_release_segmentation_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionParam.segmentation_param)
  
  ::zb::dcts::node::detection::SegmentationParam* temp = segmentation_param_;
  segmentation_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::SegmentationParam* DetectionParam::_internal_mutable_segmentation_param() {
  
  if (segmentation_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::SegmentationParam>(GetArena());
    segmentation_param_ = p;
  }
  return segmentation_param_;
}
inline ::zb::dcts::node::detection::SegmentationParam* DetectionParam::mutable_segmentation_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionParam.segmentation_param)
  return _internal_mutable_segmentation_param();
}
inline void DetectionParam::set_allocated_segmentation_param(::zb::dcts::node::detection::SegmentationParam* segmentation_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete segmentation_param_;
  }
  if (segmentation_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(segmentation_param);
    if (message_arena != submessage_arena) {
      segmentation_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segmentation_param, submessage_arena);
    }
    
  } else {
    
  }
  segmentation_param_ = segmentation_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionParam.segmentation_param)
}

// .zb.dcts.node.detection.MergeParam merge_param = 4;
inline bool DetectionParam::_internal_has_merge_param() const {
  return this != internal_default_instance() && merge_param_ != nullptr;
}
inline bool DetectionParam::has_merge_param() const {
  return _internal_has_merge_param();
}
inline void DetectionParam::clear_merge_param() {
  if (GetArena() == nullptr && merge_param_ != nullptr) {
    delete merge_param_;
  }
  merge_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::MergeParam& DetectionParam::_internal_merge_param() const {
  const ::zb::dcts::node::detection::MergeParam* p = merge_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::MergeParam&>(
      ::zb::dcts::node::detection::_MergeParam_default_instance_);
}
inline const ::zb::dcts::node::detection::MergeParam& DetectionParam::merge_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionParam.merge_param)
  return _internal_merge_param();
}
inline void DetectionParam::unsafe_arena_set_allocated_merge_param(
    ::zb::dcts::node::detection::MergeParam* merge_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(merge_param_);
  }
  merge_param_ = merge_param;
  if (merge_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionParam.merge_param)
}
inline ::zb::dcts::node::detection::MergeParam* DetectionParam::release_merge_param() {
  
  ::zb::dcts::node::detection::MergeParam* temp = merge_param_;
  merge_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::MergeParam* DetectionParam::unsafe_arena_release_merge_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionParam.merge_param)
  
  ::zb::dcts::node::detection::MergeParam* temp = merge_param_;
  merge_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::MergeParam* DetectionParam::_internal_mutable_merge_param() {
  
  if (merge_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::MergeParam>(GetArena());
    merge_param_ = p;
  }
  return merge_param_;
}
inline ::zb::dcts::node::detection::MergeParam* DetectionParam::mutable_merge_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionParam.merge_param)
  return _internal_mutable_merge_param();
}
inline void DetectionParam::set_allocated_merge_param(::zb::dcts::node::detection::MergeParam* merge_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete merge_param_;
  }
  if (merge_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(merge_param);
    if (message_arena != submessage_arena) {
      merge_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, merge_param, submessage_arena);
    }
    
  } else {
    
  }
  merge_param_ = merge_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionParam.merge_param)
}

// .zb.dcts.node.detection.DetectionOption options = 5;
inline bool DetectionParam::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool DetectionParam::has_options() const {
  return _internal_has_options();
}
inline void DetectionParam::clear_options() {
  if (GetArena() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::zb::dcts::node::detection::DetectionOption& DetectionParam::_internal_options() const {
  const ::zb::dcts::node::detection::DetectionOption* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::DetectionOption&>(
      ::zb::dcts::node::detection::_DetectionOption_default_instance_);
}
inline const ::zb::dcts::node::detection::DetectionOption& DetectionParam::options() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionParam.options)
  return _internal_options();
}
inline void DetectionParam::unsafe_arena_set_allocated_options(
    ::zb::dcts::node::detection::DetectionOption* options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionParam.options)
}
inline ::zb::dcts::node::detection::DetectionOption* DetectionParam::release_options() {
  
  ::zb::dcts::node::detection::DetectionOption* temp = options_;
  options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::DetectionOption* DetectionParam::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionParam.options)
  
  ::zb::dcts::node::detection::DetectionOption* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::DetectionOption* DetectionParam::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::DetectionOption>(GetArena());
    options_ = p;
  }
  return options_;
}
inline ::zb::dcts::node::detection::DetectionOption* DetectionParam::mutable_options() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionParam.options)
  return _internal_mutable_options();
}
inline void DetectionParam::set_allocated_options(::zb::dcts::node::detection::DetectionOption* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionParam.options)
}

// -------------------------------------------------------------------

// SignalList

// repeated .zb.dcts.node.detection.SignalSegment detected_signals = 1;
inline int SignalList::_internal_detected_signals_size() const {
  return detected_signals_.size();
}
inline int SignalList::detected_signals_size() const {
  return _internal_detected_signals_size();
}
inline void SignalList::clear_detected_signals() {
  detected_signals_.Clear();
}
inline ::zb::dcts::node::detection::SignalSegment* SignalList::mutable_detected_signals(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalList.detected_signals)
  return detected_signals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalSegment >*
SignalList::mutable_detected_signals() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.SignalList.detected_signals)
  return &detected_signals_;
}
inline const ::zb::dcts::node::detection::SignalSegment& SignalList::_internal_detected_signals(int index) const {
  return detected_signals_.Get(index);
}
inline const ::zb::dcts::node::detection::SignalSegment& SignalList::detected_signals(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalList.detected_signals)
  return _internal_detected_signals(index);
}
inline ::zb::dcts::node::detection::SignalSegment* SignalList::_internal_add_detected_signals() {
  return detected_signals_.Add();
}
inline ::zb::dcts::node::detection::SignalSegment* SignalList::add_detected_signals() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalList.detected_signals)
  return _internal_add_detected_signals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::detection::SignalSegment >&
SignalList::detected_signals() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.SignalList.detected_signals)
  return detected_signals_;
}

// repeated string merged_signal_id = 2;
inline int SignalList::_internal_merged_signal_id_size() const {
  return merged_signal_id_.size();
}
inline int SignalList::merged_signal_id_size() const {
  return _internal_merged_signal_id_size();
}
inline void SignalList::clear_merged_signal_id() {
  merged_signal_id_.Clear();
}
inline std::string* SignalList::add_merged_signal_id() {
  // @@protoc_insertion_point(field_add_mutable:zb.dcts.node.detection.SignalList.merged_signal_id)
  return _internal_add_merged_signal_id();
}
inline const std::string& SignalList::_internal_merged_signal_id(int index) const {
  return merged_signal_id_.Get(index);
}
inline const std::string& SignalList::merged_signal_id(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.SignalList.merged_signal_id)
  return _internal_merged_signal_id(index);
}
inline std::string* SignalList::mutable_merged_signal_id(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.SignalList.merged_signal_id)
  return merged_signal_id_.Mutable(index);
}
inline void SignalList::set_merged_signal_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalList.merged_signal_id)
  merged_signal_id_.Mutable(index)->assign(value);
}
inline void SignalList::set_merged_signal_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.SignalList.merged_signal_id)
  merged_signal_id_.Mutable(index)->assign(std::move(value));
}
inline void SignalList::set_merged_signal_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  merged_signal_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline void SignalList::set_merged_signal_id(int index, const char* value, size_t size) {
  merged_signal_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline std::string* SignalList::_internal_add_merged_signal_id() {
  return merged_signal_id_.Add();
}
inline void SignalList::add_merged_signal_id(const std::string& value) {
  merged_signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline void SignalList::add_merged_signal_id(std::string&& value) {
  merged_signal_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline void SignalList::add_merged_signal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  merged_signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline void SignalList::add_merged_signal_id(const char* value, size_t size) {
  merged_signal_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zb.dcts.node.detection.SignalList.merged_signal_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SignalList::merged_signal_id() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.SignalList.merged_signal_id)
  return merged_signal_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SignalList::mutable_merged_signal_id() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.SignalList.merged_signal_id)
  return &merged_signal_id_;
}

// -------------------------------------------------------------------

// DetectionRequest

// .zb.dcts.node.TaskAccount task_account = 1;
inline bool DetectionRequest::_internal_has_task_account() const {
  return this != internal_default_instance() && task_account_ != nullptr;
}
inline bool DetectionRequest::has_task_account() const {
  return _internal_has_task_account();
}
inline const ::zb::dcts::node::TaskAccount& DetectionRequest::_internal_task_account() const {
  const ::zb::dcts::node::TaskAccount* p = task_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::TaskAccount&>(
      ::zb::dcts::node::_TaskAccount_default_instance_);
}
inline const ::zb::dcts::node::TaskAccount& DetectionRequest::task_account() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionRequest.task_account)
  return _internal_task_account();
}
inline void DetectionRequest::unsafe_arena_set_allocated_task_account(
    ::zb::dcts::node::TaskAccount* task_account) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account_);
  }
  task_account_ = task_account;
  if (task_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionRequest.task_account)
}
inline ::zb::dcts::node::TaskAccount* DetectionRequest::release_task_account() {
  
  ::zb::dcts::node::TaskAccount* temp = task_account_;
  task_account_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::TaskAccount* DetectionRequest::unsafe_arena_release_task_account() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionRequest.task_account)
  
  ::zb::dcts::node::TaskAccount* temp = task_account_;
  task_account_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::TaskAccount* DetectionRequest::_internal_mutable_task_account() {
  
  if (task_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::TaskAccount>(GetArena());
    task_account_ = p;
  }
  return task_account_;
}
inline ::zb::dcts::node::TaskAccount* DetectionRequest::mutable_task_account() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionRequest.task_account)
  return _internal_mutable_task_account();
}
inline void DetectionRequest::set_allocated_task_account(::zb::dcts::node::TaskAccount* task_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account_);
  }
  if (task_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account)->GetArena();
    if (message_arena != submessage_arena) {
      task_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_account, submessage_arena);
    }
    
  } else {
    
  }
  task_account_ = task_account;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionRequest.task_account)
}

// .zb.dcts.node.detection.DetectionParam detection_param = 2;
inline bool DetectionRequest::_internal_has_detection_param() const {
  return this != internal_default_instance() && detection_param_ != nullptr;
}
inline bool DetectionRequest::has_detection_param() const {
  return _internal_has_detection_param();
}
inline void DetectionRequest::clear_detection_param() {
  if (GetArena() == nullptr && detection_param_ != nullptr) {
    delete detection_param_;
  }
  detection_param_ = nullptr;
}
inline const ::zb::dcts::node::detection::DetectionParam& DetectionRequest::_internal_detection_param() const {
  const ::zb::dcts::node::detection::DetectionParam* p = detection_param_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::DetectionParam&>(
      ::zb::dcts::node::detection::_DetectionParam_default_instance_);
}
inline const ::zb::dcts::node::detection::DetectionParam& DetectionRequest::detection_param() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetectionRequest.detection_param)
  return _internal_detection_param();
}
inline void DetectionRequest::unsafe_arena_set_allocated_detection_param(
    ::zb::dcts::node::detection::DetectionParam* detection_param) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detection_param_);
  }
  detection_param_ = detection_param;
  if (detection_param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetectionRequest.detection_param)
}
inline ::zb::dcts::node::detection::DetectionParam* DetectionRequest::release_detection_param() {
  
  ::zb::dcts::node::detection::DetectionParam* temp = detection_param_;
  detection_param_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::DetectionParam* DetectionRequest::unsafe_arena_release_detection_param() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetectionRequest.detection_param)
  
  ::zb::dcts::node::detection::DetectionParam* temp = detection_param_;
  detection_param_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::DetectionParam* DetectionRequest::_internal_mutable_detection_param() {
  
  if (detection_param_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::DetectionParam>(GetArena());
    detection_param_ = p;
  }
  return detection_param_;
}
inline ::zb::dcts::node::detection::DetectionParam* DetectionRequest::mutable_detection_param() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetectionRequest.detection_param)
  return _internal_mutable_detection_param();
}
inline void DetectionRequest::set_allocated_detection_param(::zb::dcts::node::detection::DetectionParam* detection_param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete detection_param_;
  }
  if (detection_param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(detection_param);
    if (message_arena != submessage_arena) {
      detection_param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detection_param, submessage_arena);
    }
    
  } else {
    
  }
  detection_param_ = detection_param;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetectionRequest.detection_param)
}

// -------------------------------------------------------------------

// DetailKeeping

// repeated string signal_id = 1;
inline int DetailKeeping::_internal_signal_id_size() const {
  return signal_id_.size();
}
inline int DetailKeeping::signal_id_size() const {
  return _internal_signal_id_size();
}
inline void DetailKeeping::clear_signal_id() {
  signal_id_.Clear();
}
inline std::string* DetailKeeping::add_signal_id() {
  // @@protoc_insertion_point(field_add_mutable:zb.dcts.node.detection.DetailKeeping.signal_id)
  return _internal_add_signal_id();
}
inline const std::string& DetailKeeping::_internal_signal_id(int index) const {
  return signal_id_.Get(index);
}
inline const std::string& DetailKeeping::signal_id(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetailKeeping.signal_id)
  return _internal_signal_id(index);
}
inline std::string* DetailKeeping::mutable_signal_id(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetailKeeping.signal_id)
  return signal_id_.Mutable(index);
}
inline void DetailKeeping::set_signal_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.DetailKeeping.signal_id)
  signal_id_.Mutable(index)->assign(value);
}
inline void DetailKeeping::set_signal_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.DetailKeeping.signal_id)
  signal_id_.Mutable(index)->assign(std::move(value));
}
inline void DetailKeeping::set_signal_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signal_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline void DetailKeeping::set_signal_id(int index, const char* value, size_t size) {
  signal_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline std::string* DetailKeeping::_internal_add_signal_id() {
  return signal_id_.Add();
}
inline void DetailKeeping::add_signal_id(const std::string& value) {
  signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline void DetailKeeping::add_signal_id(std::string&& value) {
  signal_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline void DetailKeeping::add_signal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signal_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline void DetailKeeping::add_signal_id(const char* value, size_t size) {
  signal_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zb.dcts.node.detection.DetailKeeping.signal_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DetailKeeping::signal_id() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.detection.DetailKeeping.signal_id)
  return signal_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DetailKeeping::mutable_signal_id() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.detection.DetailKeeping.signal_id)
  return &signal_id_;
}

// bool keeping = 2;
inline void DetailKeeping::clear_keeping() {
  keeping_ = false;
}
inline bool DetailKeeping::_internal_keeping() const {
  return keeping_;
}
inline bool DetailKeeping::keeping() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetailKeeping.keeping)
  return _internal_keeping();
}
inline void DetailKeeping::_internal_set_keeping(bool value) {
  
  keeping_ = value;
}
inline void DetailKeeping::set_keeping(bool value) {
  _internal_set_keeping(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.detection.DetailKeeping.keeping)
}

// -------------------------------------------------------------------

// DetailKeepingRequest

// .zb.dcts.node.TaskAccount task_account = 1;
inline bool DetailKeepingRequest::_internal_has_task_account() const {
  return this != internal_default_instance() && task_account_ != nullptr;
}
inline bool DetailKeepingRequest::has_task_account() const {
  return _internal_has_task_account();
}
inline const ::zb::dcts::node::TaskAccount& DetailKeepingRequest::_internal_task_account() const {
  const ::zb::dcts::node::TaskAccount* p = task_account_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::TaskAccount&>(
      ::zb::dcts::node::_TaskAccount_default_instance_);
}
inline const ::zb::dcts::node::TaskAccount& DetailKeepingRequest::task_account() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetailKeepingRequest.task_account)
  return _internal_task_account();
}
inline void DetailKeepingRequest::unsafe_arena_set_allocated_task_account(
    ::zb::dcts::node::TaskAccount* task_account) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account_);
  }
  task_account_ = task_account;
  if (task_account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetailKeepingRequest.task_account)
}
inline ::zb::dcts::node::TaskAccount* DetailKeepingRequest::release_task_account() {
  
  ::zb::dcts::node::TaskAccount* temp = task_account_;
  task_account_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::TaskAccount* DetailKeepingRequest::unsafe_arena_release_task_account() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetailKeepingRequest.task_account)
  
  ::zb::dcts::node::TaskAccount* temp = task_account_;
  task_account_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::TaskAccount* DetailKeepingRequest::_internal_mutable_task_account() {
  
  if (task_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::TaskAccount>(GetArena());
    task_account_ = p;
  }
  return task_account_;
}
inline ::zb::dcts::node::TaskAccount* DetailKeepingRequest::mutable_task_account() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetailKeepingRequest.task_account)
  return _internal_mutable_task_account();
}
inline void DetailKeepingRequest::set_allocated_task_account(::zb::dcts::node::TaskAccount* task_account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account_);
  }
  if (task_account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_account)->GetArena();
    if (message_arena != submessage_arena) {
      task_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_account, submessage_arena);
    }
    
  } else {
    
  }
  task_account_ = task_account;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetailKeepingRequest.task_account)
}

// .zb.dcts.node.detection.DetailKeeping detail_keeping = 2;
inline bool DetailKeepingRequest::_internal_has_detail_keeping() const {
  return this != internal_default_instance() && detail_keeping_ != nullptr;
}
inline bool DetailKeepingRequest::has_detail_keeping() const {
  return _internal_has_detail_keeping();
}
inline void DetailKeepingRequest::clear_detail_keeping() {
  if (GetArena() == nullptr && detail_keeping_ != nullptr) {
    delete detail_keeping_;
  }
  detail_keeping_ = nullptr;
}
inline const ::zb::dcts::node::detection::DetailKeeping& DetailKeepingRequest::_internal_detail_keeping() const {
  const ::zb::dcts::node::detection::DetailKeeping* p = detail_keeping_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::detection::DetailKeeping&>(
      ::zb::dcts::node::detection::_DetailKeeping_default_instance_);
}
inline const ::zb::dcts::node::detection::DetailKeeping& DetailKeepingRequest::detail_keeping() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.detection.DetailKeepingRequest.detail_keeping)
  return _internal_detail_keeping();
}
inline void DetailKeepingRequest::unsafe_arena_set_allocated_detail_keeping(
    ::zb::dcts::node::detection::DetailKeeping* detail_keeping) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detail_keeping_);
  }
  detail_keeping_ = detail_keeping;
  if (detail_keeping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.detection.DetailKeepingRequest.detail_keeping)
}
inline ::zb::dcts::node::detection::DetailKeeping* DetailKeepingRequest::release_detail_keeping() {
  
  ::zb::dcts::node::detection::DetailKeeping* temp = detail_keeping_;
  detail_keeping_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::detection::DetailKeeping* DetailKeepingRequest::unsafe_arena_release_detail_keeping() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.detection.DetailKeepingRequest.detail_keeping)
  
  ::zb::dcts::node::detection::DetailKeeping* temp = detail_keeping_;
  detail_keeping_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::detection::DetailKeeping* DetailKeepingRequest::_internal_mutable_detail_keeping() {
  
  if (detail_keeping_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::detection::DetailKeeping>(GetArena());
    detail_keeping_ = p;
  }
  return detail_keeping_;
}
inline ::zb::dcts::node::detection::DetailKeeping* DetailKeepingRequest::mutable_detail_keeping() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.detection.DetailKeepingRequest.detail_keeping)
  return _internal_mutable_detail_keeping();
}
inline void DetailKeepingRequest::set_allocated_detail_keeping(::zb::dcts::node::detection::DetailKeeping* detail_keeping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete detail_keeping_;
  }
  if (detail_keeping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(detail_keeping);
    if (message_arena != submessage_arena) {
      detail_keeping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detail_keeping, submessage_arena);
    }
    
  } else {
    
  }
  detail_keeping_ = detail_keeping;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.detection.DetailKeepingRequest.detail_keeping)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace detection
}  // namespace node
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode>() {
  return ::zb::dcts::node::detection::AdaptiveThresholdParam_PartitionMode_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::detection::EnergyDetectionParam_LogicType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::EnergyDetectionParam_LogicType>() {
  return ::zb::dcts::node::detection::EnergyDetectionParam_LogicType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::detection::ThresholdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::ThresholdType>() {
  return ::zb::dcts::node::detection::ThresholdType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::detection::SignalActivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::SignalActivity>() {
  return ::zb::dcts::node::detection::SignalActivity_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::detection::SegmentationFilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::SegmentationFilterType>() {
  return ::zb::dcts::node::detection::SegmentationFilterType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::detection::MergePolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::detection::MergePolicy>() {
  return ::zb::dcts::node::detection::MergePolicy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_2fdetection_2eproto
