// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node/node.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_2fnode_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_2fnode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dcts.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_2fnode_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_2fnode_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_node_2fnode_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_node_2fnode_2eproto_metadata_getter(int index);
namespace zb {
namespace dcts {
namespace node {
class CmdHeader;
struct CmdHeaderDefaultTypeInternal;
extern CmdHeaderDefaultTypeInternal _CmdHeader_default_instance_;
class DeviceId;
struct DeviceIdDefaultTypeInternal;
extern DeviceIdDefaultTypeInternal _DeviceId_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class NodeDevice;
struct NodeDeviceDefaultTypeInternal;
extern NodeDeviceDefaultTypeInternal _NodeDevice_default_instance_;
class NodeId;
struct NodeIdDefaultTypeInternal;
extern NodeIdDefaultTypeInternal _NodeId_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeReply;
struct NodeReplyDefaultTypeInternal;
extern NodeReplyDefaultTypeInternal _NodeReply_default_instance_;
class NodesInfo;
struct NodesInfoDefaultTypeInternal;
extern NodesInfoDefaultTypeInternal _NodesInfo_default_instance_;
class TaskAccount;
struct TaskAccountDefaultTypeInternal;
extern TaskAccountDefaultTypeInternal _TaskAccount_default_instance_;
class TaskSummary;
struct TaskSummaryDefaultTypeInternal;
extern TaskSummaryDefaultTypeInternal _TaskSummary_default_instance_;
class TaskType;
struct TaskTypeDefaultTypeInternal;
extern TaskTypeDefaultTypeInternal _TaskType_default_instance_;
class TransferStatus;
struct TransferStatusDefaultTypeInternal;
extern TransferStatusDefaultTypeInternal _TransferStatus_default_instance_;
}  // namespace node
}  // namespace dcts
}  // namespace zb
PROTOBUF_NAMESPACE_OPEN
template<> ::zb::dcts::node::CmdHeader* Arena::CreateMaybeMessage<::zb::dcts::node::CmdHeader>(Arena*);
template<> ::zb::dcts::node::DeviceId* Arena::CreateMaybeMessage<::zb::dcts::node::DeviceId>(Arena*);
template<> ::zb::dcts::node::DeviceInfo* Arena::CreateMaybeMessage<::zb::dcts::node::DeviceInfo>(Arena*);
template<> ::zb::dcts::node::NodeDevice* Arena::CreateMaybeMessage<::zb::dcts::node::NodeDevice>(Arena*);
template<> ::zb::dcts::node::NodeId* Arena::CreateMaybeMessage<::zb::dcts::node::NodeId>(Arena*);
template<> ::zb::dcts::node::NodeInfo* Arena::CreateMaybeMessage<::zb::dcts::node::NodeInfo>(Arena*);
template<> ::zb::dcts::node::NodeReply* Arena::CreateMaybeMessage<::zb::dcts::node::NodeReply>(Arena*);
template<> ::zb::dcts::node::NodesInfo* Arena::CreateMaybeMessage<::zb::dcts::node::NodesInfo>(Arena*);
template<> ::zb::dcts::node::TaskAccount* Arena::CreateMaybeMessage<::zb::dcts::node::TaskAccount>(Arena*);
template<> ::zb::dcts::node::TaskSummary* Arena::CreateMaybeMessage<::zb::dcts::node::TaskSummary>(Arena*);
template<> ::zb::dcts::node::TaskType* Arena::CreateMaybeMessage<::zb::dcts::node::TaskType>(Arena*);
template<> ::zb::dcts::node::TransferStatus* Arena::CreateMaybeMessage<::zb::dcts::node::TransferStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zb {
namespace dcts {
namespace node {

enum PrimaryTaskType : int {
  NULL_TASK = 0,
  HYBRID_TASK = 1,
  SENSOR_TASK = 2,
  RADAR_DF_TASK = 3,
  CZC_QJ_TASK = 4,
  CZC_DF_TASK = 5,
  CZC_SM_TASK = 6,
  DEMO_TASK = 7,
  ZCZH_TASK = 8,
  PrimaryTaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PrimaryTaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PrimaryTaskType_IsValid(int value);
constexpr PrimaryTaskType PrimaryTaskType_MIN = NULL_TASK;
constexpr PrimaryTaskType PrimaryTaskType_MAX = ZCZH_TASK;
constexpr int PrimaryTaskType_ARRAYSIZE = PrimaryTaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrimaryTaskType_descriptor();
template<typename T>
inline const std::string& PrimaryTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrimaryTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrimaryTaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrimaryTaskType_descriptor(), enum_t_value);
}
inline bool PrimaryTaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrimaryTaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimaryTaskType>(
    PrimaryTaskType_descriptor(), name, value);
}
enum SecondaryTaskType : int {
  SELF_TEST = 0,
  CAL1 = 1,
  CAL2 = 2,
  EXAMPLE = 3,
  PSCAN = 16,
  IF_SCAN = 17,
  PULSE_ANALYSIS = 18,
  PULSE_ANALYSIS_2 = 19,
  OSCILLOSCOPE = 20,
  VECTOR_SIGNAL_ANALYSIS = 21,
  IQ_RECORDER = 22,
  SIGNAL_GENERATOR = 23,
  POSITION_TDOA = 32,
  DIRECTION_FINDING_AOA = 33,
  DIRECTION_FINDING_SPATIAL_SPECTRUM = 34,
  DEMODULATE_ANALOG = 48,
  CLASSIFY_MODULATE = 56,
  CLASSIFY_ENCODE = 58,
  CLASSIFY_COMM_SYS = 60,
  DECODE_ADS_B = 70,
  DECODE_ACARS = 71,
  DECODE_AIS = 72,
  IQ_ACQUIRE = 73,
  DEMO_DETECT = 80,
  REPLAY_PSCAN = 81,
  REPLAY_DECODE_ADS_B = 90,
  REPLAY_DECODE_ACARS = 91,
  REPLAY_DECODE_AIS = 92,
  REPLAY_IQ = 93,
  REPLAY_TDOA = 94,
  REPLAY_DEMODULATE_ANALOG = 95,
  SecondaryTaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SecondaryTaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SecondaryTaskType_IsValid(int value);
constexpr SecondaryTaskType SecondaryTaskType_MIN = SELF_TEST;
constexpr SecondaryTaskType SecondaryTaskType_MAX = REPLAY_DEMODULATE_ANALOG;
constexpr int SecondaryTaskType_ARRAYSIZE = SecondaryTaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecondaryTaskType_descriptor();
template<typename T>
inline const std::string& SecondaryTaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecondaryTaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecondaryTaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecondaryTaskType_descriptor(), enum_t_value);
}
inline bool SecondaryTaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecondaryTaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecondaryTaskType>(
    SecondaryTaskType_descriptor(), name, value);
}
enum TaskStatus : int {
  T_READY = 0,
  T_RUN = 1,
  T_ABORT = 2,
  T_FINISH = 3,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = T_READY;
constexpr TaskStatus TaskStatus_MAX = T_FINISH;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum DeviceType : int {
  SENSOR_3900 = 0,
  RADAR_DF = 1,
  CZC_SM = 2,
  CZC_DF = 3,
  CZC_QJ = 4,
  DEMO = 5,
  ZCZH = 6,
  DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeviceType_IsValid(int value);
constexpr DeviceType DeviceType_MIN = SENSOR_3900;
constexpr DeviceType DeviceType_MAX = ZCZH;
constexpr int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceType_descriptor();
template<typename T>
inline const std::string& DeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceType_descriptor(), enum_t_value);
}
inline bool DeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum DeviceStatus : int {
  D_OFFLINE = 0,
  D_IDLE = 1,
  D_ENGAGED = 2,
  D_ABNORMAL = 3,
  DeviceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeviceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeviceStatus_IsValid(int value);
constexpr DeviceStatus DeviceStatus_MIN = D_OFFLINE;
constexpr DeviceStatus DeviceStatus_MAX = D_ABNORMAL;
constexpr int DeviceStatus_ARRAYSIZE = DeviceStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceStatus_descriptor();
template<typename T>
inline const std::string& DeviceStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceStatus_descriptor(), enum_t_value);
}
inline bool DeviceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceStatus>(
    DeviceStatus_descriptor(), name, value);
}
enum ErrorType : int {
  ERR_NONE = 0,
  ERR_NOTIMPLEMENTED = -1,
  ERR_UNKNOWN = -2,
  ERR_BUSY = -3,
  ERR_ABORTED = -5,
  ERR_CMD_NOREPLY = -6,
  ERR_PARAM = -8,
  ERR_STATION_NAME_EXISTS = -11,
  ERR_INVALID_HANDLE = -15,
  ERR_INVALID_REQUEST = -16,
  ERR_NO_SENSORS = -20,
  ERR_SOCKET_ERROR = -26,
  ERR_NODE_NOT_FOUND = -27,
  ERR_NO_DATA_AVAILABLE = -28,
  ERR_BUFFER_TOO_SMALL = -30,
  ERR_DIAGNOSTIC = -31,
  ERR_COMMAND_FAILED = -38,
  ERR_TIMEOUT = -40,
  ERR_STRING_TOO_LONG = -43,
  ERR_DATA_TYPE = -52,
  ERR_AUTHORIZATION = -57,
  ERR_LICENSE = -64,
  ERR_MEAS_FAILED = -66,
  ERR_DATA_AVAIL_TIMEOUT = -75,
  ERR_TASK_NOT_FOUND = -76,
  ERR_NODE_TASK_ASSIGN = -77,
  ERR_SENSOR_TASK_ASSIGN = -78,
  ERR_SENSOR_TASK_START = -79,
  ERR_OPEN_FILE = -80,
  ERR_COMPASS_NOT_AVAILABLE = -81,
  ERR_TDOA = -82,
  ERR_TASK_QUIT = -83,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorType_IsValid(int value);
constexpr ErrorType ErrorType_MIN = ERR_TASK_QUIT;
constexpr ErrorType ErrorType_MAX = ERR_NONE;
constexpr int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor();
template<typename T>
inline const std::string& ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorType_descriptor(), enum_t_value);
}
inline bool ErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
// ===================================================================

class NodeId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.NodeId) */ {
 public:
  inline NodeId() : NodeId(nullptr) {}
  virtual ~NodeId();
  explicit constexpr NodeId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeId(const NodeId& from);
  NodeId(NodeId&& from) noexcept
    : NodeId() {
    *this = ::std::move(from);
  }

  inline NodeId& operator=(const NodeId& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeId& operator=(NodeId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeId& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeId* internal_default_instance() {
    return reinterpret_cast<const NodeId*>(
               &_NodeId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeId& a, NodeId& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeId* New() const final {
    return CreateMaybeMessage<NodeId>(nullptr);
  }

  NodeId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeId& from);
  void MergeFrom(const NodeId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.NodeId";
  }
  protected:
  explicit NodeId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.NodeId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class DeviceId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.DeviceId) */ {
 public:
  inline DeviceId() : DeviceId(nullptr) {}
  virtual ~DeviceId();
  explicit constexpr DeviceId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceId(const DeviceId& from);
  DeviceId(DeviceId&& from) noexcept
    : DeviceId() {
    *this = ::std::move(from);
  }

  inline DeviceId& operator=(const DeviceId& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceId& operator=(DeviceId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceId& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceId* internal_default_instance() {
    return reinterpret_cast<const DeviceId*>(
               &_DeviceId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceId& a, DeviceId& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceId* New() const final {
    return CreateMaybeMessage<DeviceId>(nullptr);
  }

  DeviceId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceId& from);
  void MergeFrom(const DeviceId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.DeviceId";
  }
  protected:
  explicit DeviceId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.DeviceId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class NodeDevice PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.NodeDevice) */ {
 public:
  inline NodeDevice() : NodeDevice(nullptr) {}
  virtual ~NodeDevice();
  explicit constexpr NodeDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeDevice(const NodeDevice& from);
  NodeDevice(NodeDevice&& from) noexcept
    : NodeDevice() {
    *this = ::std::move(from);
  }

  inline NodeDevice& operator=(const NodeDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeDevice& operator=(NodeDevice&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeDevice* internal_default_instance() {
    return reinterpret_cast<const NodeDevice*>(
               &_NodeDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeDevice& a, NodeDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeDevice* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeDevice* New() const final {
    return CreateMaybeMessage<NodeDevice>(nullptr);
  }

  NodeDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeDevice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeDevice& from);
  void MergeFrom(const NodeDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeDevice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.NodeDevice";
  }
  protected:
  explicit NodeDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // .zb.dcts.node.NodeId node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const ::zb::dcts::node::NodeId& node_id() const;
  ::zb::dcts::node::NodeId* release_node_id();
  ::zb::dcts::node::NodeId* mutable_node_id();
  void set_allocated_node_id(::zb::dcts::node::NodeId* node_id);
  private:
  const ::zb::dcts::node::NodeId& _internal_node_id() const;
  ::zb::dcts::node::NodeId* _internal_mutable_node_id();
  public:
  void unsafe_arena_set_allocated_node_id(
      ::zb::dcts::node::NodeId* node_id);
  ::zb::dcts::node::NodeId* unsafe_arena_release_node_id();

  // .zb.dcts.node.DeviceId device_id = 2;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  const ::zb::dcts::node::DeviceId& device_id() const;
  ::zb::dcts::node::DeviceId* release_device_id();
  ::zb::dcts::node::DeviceId* mutable_device_id();
  void set_allocated_device_id(::zb::dcts::node::DeviceId* device_id);
  private:
  const ::zb::dcts::node::DeviceId& _internal_device_id() const;
  ::zb::dcts::node::DeviceId* _internal_mutable_device_id();
  public:
  void unsafe_arena_set_allocated_device_id(
      ::zb::dcts::node::DeviceId* device_id);
  ::zb::dcts::node::DeviceId* unsafe_arena_release_device_id();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.NodeDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::node::NodeId* node_id_;
  ::zb::dcts::node::DeviceId* device_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class TaskType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.TaskType) */ {
 public:
  inline TaskType() : TaskType(nullptr) {}
  virtual ~TaskType();
  explicit constexpr TaskType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskType(const TaskType& from);
  TaskType(TaskType&& from) noexcept
    : TaskType() {
    *this = ::std::move(from);
  }

  inline TaskType& operator=(const TaskType& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskType& operator=(TaskType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskType& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskType* internal_default_instance() {
    return reinterpret_cast<const TaskType*>(
               &_TaskType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TaskType& a, TaskType& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskType* New() const final {
    return CreateMaybeMessage<TaskType>(nullptr);
  }

  TaskType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskType& from);
  void MergeFrom(const TaskType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.TaskType";
  }
  protected:
  explicit TaskType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriTaskTypeFieldNumber = 1,
    kSecTaskTypeFieldNumber = 2,
  };
  // .zb.dcts.node.PrimaryTaskType pri_task_type = 1;
  void clear_pri_task_type();
  ::zb::dcts::node::PrimaryTaskType pri_task_type() const;
  void set_pri_task_type(::zb::dcts::node::PrimaryTaskType value);
  private:
  ::zb::dcts::node::PrimaryTaskType _internal_pri_task_type() const;
  void _internal_set_pri_task_type(::zb::dcts::node::PrimaryTaskType value);
  public:

  // .zb.dcts.node.SecondaryTaskType sec_task_type = 2;
  void clear_sec_task_type();
  ::zb::dcts::node::SecondaryTaskType sec_task_type() const;
  void set_sec_task_type(::zb::dcts::node::SecondaryTaskType value);
  private:
  ::zb::dcts::node::SecondaryTaskType _internal_sec_task_type() const;
  void _internal_set_sec_task_type(::zb::dcts::node::SecondaryTaskType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.TaskType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int pri_task_type_;
  int sec_task_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class TaskSummary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.TaskSummary) */ {
 public:
  inline TaskSummary() : TaskSummary(nullptr) {}
  virtual ~TaskSummary();
  explicit constexpr TaskSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskSummary(const TaskSummary& from);
  TaskSummary(TaskSummary&& from) noexcept
    : TaskSummary() {
    *this = ::std::move(from);
  }

  inline TaskSummary& operator=(const TaskSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskSummary& operator=(TaskSummary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskSummary* internal_default_instance() {
    return reinterpret_cast<const TaskSummary*>(
               &_TaskSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TaskSummary& a, TaskSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskSummary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskSummary* New() const final {
    return CreateMaybeMessage<TaskSummary>(nullptr);
  }

  TaskSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskSummary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskSummary& from);
  void MergeFrom(const TaskSummary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskSummary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.TaskSummary";
  }
  protected:
  explicit TaskSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kDeviceFieldNumber = 3,
    kStartTimeFieldNumber = 5,
    kStatusFieldNumber = 4,
  };
  // .zb.dcts.TaskId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::TaskId& id() const;
  ::zb::dcts::TaskId* release_id();
  ::zb::dcts::TaskId* mutable_id();
  void set_allocated_id(::zb::dcts::TaskId* id);
  private:
  const ::zb::dcts::TaskId& _internal_id() const;
  ::zb::dcts::TaskId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::TaskId* id);
  ::zb::dcts::TaskId* unsafe_arena_release_id();

  // .zb.dcts.node.TaskType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::zb::dcts::node::TaskType& type() const;
  ::zb::dcts::node::TaskType* release_type();
  ::zb::dcts::node::TaskType* mutable_type();
  void set_allocated_type(::zb::dcts::node::TaskType* type);
  private:
  const ::zb::dcts::node::TaskType& _internal_type() const;
  ::zb::dcts::node::TaskType* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::zb::dcts::node::TaskType* type);
  ::zb::dcts::node::TaskType* unsafe_arena_release_type();

  // .zb.dcts.node.DeviceId device = 3;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::zb::dcts::node::DeviceId& device() const;
  ::zb::dcts::node::DeviceId* release_device();
  ::zb::dcts::node::DeviceId* mutable_device();
  void set_allocated_device(::zb::dcts::node::DeviceId* device);
  private:
  const ::zb::dcts::node::DeviceId& _internal_device() const;
  ::zb::dcts::node::DeviceId* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::zb::dcts::node::DeviceId* device);
  ::zb::dcts::node::DeviceId* unsafe_arena_release_device();

  // .zb.dcts.Timestamp startTime = 5;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const ::zb::dcts::Timestamp& starttime() const;
  ::zb::dcts::Timestamp* release_starttime();
  ::zb::dcts::Timestamp* mutable_starttime();
  void set_allocated_starttime(::zb::dcts::Timestamp* starttime);
  private:
  const ::zb::dcts::Timestamp& _internal_starttime() const;
  ::zb::dcts::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      ::zb::dcts::Timestamp* starttime);
  ::zb::dcts::Timestamp* unsafe_arena_release_starttime();

  // .zb.dcts.node.TaskStatus status = 4;
  void clear_status();
  ::zb::dcts::node::TaskStatus status() const;
  void set_status(::zb::dcts::node::TaskStatus value);
  private:
  ::zb::dcts::node::TaskStatus _internal_status() const;
  void _internal_set_status(::zb::dcts::node::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.TaskSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::TaskId* id_;
  ::zb::dcts::node::TaskType* type_;
  ::zb::dcts::node::DeviceId* device_;
  ::zb::dcts::Timestamp* starttime_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  virtual ~DeviceInfo();
  explicit constexpr DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalsFieldNumber = 6,
    kIdFieldNumber = 1,
    kPositionFieldNumber = 4,
    kPostureFieldNumber = 5,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // repeated .zb.dcts.Physical physicals = 6;
  int physicals_size() const;
  private:
  int _internal_physicals_size() const;
  public:
  void clear_physicals();
  ::zb::dcts::Physical* mutable_physicals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Physical >*
      mutable_physicals();
  private:
  const ::zb::dcts::Physical& _internal_physicals(int index) const;
  ::zb::dcts::Physical* _internal_add_physicals();
  public:
  const ::zb::dcts::Physical& physicals(int index) const;
  ::zb::dcts::Physical* add_physicals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Physical >&
      physicals() const;

  // .zb.dcts.node.DeviceId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::node::DeviceId& id() const;
  ::zb::dcts::node::DeviceId* release_id();
  ::zb::dcts::node::DeviceId* mutable_id();
  void set_allocated_id(::zb::dcts::node::DeviceId* id);
  private:
  const ::zb::dcts::node::DeviceId& _internal_id() const;
  ::zb::dcts::node::DeviceId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::node::DeviceId* id);
  ::zb::dcts::node::DeviceId* unsafe_arena_release_id();

  // .zb.dcts.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::zb::dcts::Position& position() const;
  ::zb::dcts::Position* release_position();
  ::zb::dcts::Position* mutable_position();
  void set_allocated_position(::zb::dcts::Position* position);
  private:
  const ::zb::dcts::Position& _internal_position() const;
  ::zb::dcts::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::zb::dcts::Position* position);
  ::zb::dcts::Position* unsafe_arena_release_position();

  // .zb.dcts.Posture posture = 5;
  bool has_posture() const;
  private:
  bool _internal_has_posture() const;
  public:
  void clear_posture();
  const ::zb::dcts::Posture& posture() const;
  ::zb::dcts::Posture* release_posture();
  ::zb::dcts::Posture* mutable_posture();
  void set_allocated_posture(::zb::dcts::Posture* posture);
  private:
  const ::zb::dcts::Posture& _internal_posture() const;
  ::zb::dcts::Posture* _internal_mutable_posture();
  public:
  void unsafe_arena_set_allocated_posture(
      ::zb::dcts::Posture* posture);
  ::zb::dcts::Posture* unsafe_arena_release_posture();

  // .zb.dcts.node.DeviceType type = 2;
  void clear_type();
  ::zb::dcts::node::DeviceType type() const;
  void set_type(::zb::dcts::node::DeviceType value);
  private:
  ::zb::dcts::node::DeviceType _internal_type() const;
  void _internal_set_type(::zb::dcts::node::DeviceType value);
  public:

  // .zb.dcts.node.DeviceStatus status = 3;
  void clear_status();
  ::zb::dcts::node::DeviceStatus status() const;
  void set_status(::zb::dcts::node::DeviceStatus value);
  private:
  ::zb::dcts::node::DeviceStatus _internal_status() const;
  void _internal_set_status(::zb::dcts::node::DeviceStatus value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Physical > physicals_;
  ::zb::dcts::node::DeviceId* id_;
  ::zb::dcts::Position* position_;
  ::zb::dcts::Posture* posture_;
  int type_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class TransferStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.TransferStatus) */ {
 public:
  inline TransferStatus() : TransferStatus(nullptr) {}
  virtual ~TransferStatus();
  explicit constexpr TransferStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferStatus(const TransferStatus& from);
  TransferStatus(TransferStatus&& from) noexcept
    : TransferStatus() {
    *this = ::std::move(from);
  }

  inline TransferStatus& operator=(const TransferStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferStatus& operator=(TransferStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferStatus* internal_default_instance() {
    return reinterpret_cast<const TransferStatus*>(
               &_TransferStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TransferStatus& a, TransferStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferStatus* New() const final {
    return CreateMaybeMessage<TransferStatus>(nullptr);
  }

  TransferStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferStatus& from);
  void MergeFrom(const TransferStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.TransferStatus";
  }
  protected:
  explicit TransferStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSendFailTimesFieldNumber = 1,
    kBlockedTimesFieldNumber = 2,
    kSendedMessageCountFieldNumber = 3,
  };
  // uint32 send_fail_times = 1;
  void clear_send_fail_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 send_fail_times() const;
  void set_send_fail_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_send_fail_times() const;
  void _internal_set_send_fail_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 blocked_times = 2;
  void clear_blocked_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 blocked_times() const;
  void set_blocked_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blocked_times() const;
  void _internal_set_blocked_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 sended_message_count = 3;
  void clear_sended_message_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 sended_message_count() const;
  void set_sended_message_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sended_message_count() const;
  void _internal_set_sended_message_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.TransferStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 send_fail_times_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blocked_times_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sended_message_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  virtual ~NodeInfo();
  explicit constexpr NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(nullptr);
  }

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 6,
    kDevicesFieldNumber = 7,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kLastHeardFieldNumber = 3,
    kPipelineStatusFieldNumber = 8,
  };
  // repeated .zb.dcts.node.TaskSummary tasks = 6;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::zb::dcts::node::TaskSummary* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::TaskSummary >*
      mutable_tasks();
  private:
  const ::zb::dcts::node::TaskSummary& _internal_tasks(int index) const;
  ::zb::dcts::node::TaskSummary* _internal_add_tasks();
  public:
  const ::zb::dcts::node::TaskSummary& tasks(int index) const;
  ::zb::dcts::node::TaskSummary* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::TaskSummary >&
      tasks() const;

  // repeated .zb.dcts.node.DeviceInfo devices = 7;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::zb::dcts::node::DeviceInfo* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::DeviceInfo >*
      mutable_devices();
  private:
  const ::zb::dcts::node::DeviceInfo& _internal_devices(int index) const;
  ::zb::dcts::node::DeviceInfo* _internal_add_devices();
  public:
  const ::zb::dcts::node::DeviceInfo& devices(int index) const;
  ::zb::dcts::node::DeviceInfo* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::DeviceInfo >&
      devices() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .zb.dcts.node.NodeId id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::zb::dcts::node::NodeId& id() const;
  ::zb::dcts::node::NodeId* release_id();
  ::zb::dcts::node::NodeId* mutable_id();
  void set_allocated_id(::zb::dcts::node::NodeId* id);
  private:
  const ::zb::dcts::node::NodeId& _internal_id() const;
  ::zb::dcts::node::NodeId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::zb::dcts::node::NodeId* id);
  ::zb::dcts::node::NodeId* unsafe_arena_release_id();

  // .zb.dcts.Timestamp last_heard = 3;
  bool has_last_heard() const;
  private:
  bool _internal_has_last_heard() const;
  public:
  void clear_last_heard();
  const ::zb::dcts::Timestamp& last_heard() const;
  ::zb::dcts::Timestamp* release_last_heard();
  ::zb::dcts::Timestamp* mutable_last_heard();
  void set_allocated_last_heard(::zb::dcts::Timestamp* last_heard);
  private:
  const ::zb::dcts::Timestamp& _internal_last_heard() const;
  ::zb::dcts::Timestamp* _internal_mutable_last_heard();
  public:
  void unsafe_arena_set_allocated_last_heard(
      ::zb::dcts::Timestamp* last_heard);
  ::zb::dcts::Timestamp* unsafe_arena_release_last_heard();

  // .zb.dcts.node.TransferStatus pipeline_status = 8;
  bool has_pipeline_status() const;
  private:
  bool _internal_has_pipeline_status() const;
  public:
  void clear_pipeline_status();
  const ::zb::dcts::node::TransferStatus& pipeline_status() const;
  ::zb::dcts::node::TransferStatus* release_pipeline_status();
  ::zb::dcts::node::TransferStatus* mutable_pipeline_status();
  void set_allocated_pipeline_status(::zb::dcts::node::TransferStatus* pipeline_status);
  private:
  const ::zb::dcts::node::TransferStatus& _internal_pipeline_status() const;
  ::zb::dcts::node::TransferStatus* _internal_mutable_pipeline_status();
  public:
  void unsafe_arena_set_allocated_pipeline_status(
      ::zb::dcts::node::TransferStatus* pipeline_status);
  ::zb::dcts::node::TransferStatus* unsafe_arena_release_pipeline_status();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::TaskSummary > tasks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::DeviceInfo > devices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::zb::dcts::node::NodeId* id_;
  ::zb::dcts::Timestamp* last_heard_;
  ::zb::dcts::node::TransferStatus* pipeline_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class CmdHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.CmdHeader) */ {
 public:
  inline CmdHeader() : CmdHeader(nullptr) {}
  virtual ~CmdHeader();
  explicit constexpr CmdHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CmdHeader(const CmdHeader& from);
  CmdHeader(CmdHeader&& from) noexcept
    : CmdHeader() {
    *this = ::std::move(from);
  }

  inline CmdHeader& operator=(const CmdHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CmdHeader& operator=(CmdHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CmdHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CmdHeader* internal_default_instance() {
    return reinterpret_cast<const CmdHeader*>(
               &_CmdHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CmdHeader& a, CmdHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CmdHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CmdHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CmdHeader* New() const final {
    return CreateMaybeMessage<CmdHeader>(nullptr);
  }

  CmdHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CmdHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CmdHeader& from);
  void MergeFrom(const CmdHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.CmdHeader";
  }
  protected:
  explicit CmdHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 3,
    kTaskRunnerFieldNumber = 4,
    kSequenceNumberFieldNumber = 1,
    kErrorCodeFieldNumber = 2,
  };
  // .zb.dcts.TaskId task_id = 3;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::zb::dcts::TaskId& task_id() const;
  ::zb::dcts::TaskId* release_task_id();
  ::zb::dcts::TaskId* mutable_task_id();
  void set_allocated_task_id(::zb::dcts::TaskId* task_id);
  private:
  const ::zb::dcts::TaskId& _internal_task_id() const;
  ::zb::dcts::TaskId* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::zb::dcts::TaskId* task_id);
  ::zb::dcts::TaskId* unsafe_arena_release_task_id();

  // .zb.dcts.node.NodeDevice task_runner = 4;
  bool has_task_runner() const;
  private:
  bool _internal_has_task_runner() const;
  public:
  void clear_task_runner();
  const ::zb::dcts::node::NodeDevice& task_runner() const;
  ::zb::dcts::node::NodeDevice* release_task_runner();
  ::zb::dcts::node::NodeDevice* mutable_task_runner();
  void set_allocated_task_runner(::zb::dcts::node::NodeDevice* task_runner);
  private:
  const ::zb::dcts::node::NodeDevice& _internal_task_runner() const;
  ::zb::dcts::node::NodeDevice* _internal_mutable_task_runner();
  public:
  void unsafe_arena_set_allocated_task_runner(
      ::zb::dcts::node::NodeDevice* task_runner);
  ::zb::dcts::node::NodeDevice* unsafe_arena_release_task_runner();

  // uint32 sequence_number = 1;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .zb.dcts.node.ErrorType error_code = 2;
  void clear_error_code();
  ::zb::dcts::node::ErrorType error_code() const;
  void set_error_code(::zb::dcts::node::ErrorType value);
  private:
  ::zb::dcts::node::ErrorType _internal_error_code() const;
  void _internal_set_error_code(::zb::dcts::node::ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:zb.dcts.node.CmdHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::zb::dcts::TaskId* task_id_;
  ::zb::dcts::node::NodeDevice* task_runner_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number_;
  int error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class NodeReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.NodeReply) */ {
 public:
  inline NodeReply() : NodeReply(nullptr) {}
  virtual ~NodeReply();
  explicit constexpr NodeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeReply(const NodeReply& from);
  NodeReply(NodeReply&& from) noexcept
    : NodeReply() {
    *this = ::std::move(from);
  }

  inline NodeReply& operator=(const NodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeReply& operator=(NodeReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeReply* internal_default_instance() {
    return reinterpret_cast<const NodeReply*>(
               &_NodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NodeReply& a, NodeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeReply* New() const final {
    return CreateMaybeMessage<NodeReply>(nullptr);
  }

  NodeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeReply& from);
  void MergeFrom(const NodeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.NodeReply";
  }
  protected:
  explicit NodeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplysFieldNumber = 1,
  };
  // repeated .zb.dcts.node.CmdHeader replys = 1;
  int replys_size() const;
  private:
  int _internal_replys_size() const;
  public:
  void clear_replys();
  ::zb::dcts::node::CmdHeader* mutable_replys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::CmdHeader >*
      mutable_replys();
  private:
  const ::zb::dcts::node::CmdHeader& _internal_replys(int index) const;
  ::zb::dcts::node::CmdHeader* _internal_add_replys();
  public:
  const ::zb::dcts::node::CmdHeader& replys(int index) const;
  ::zb::dcts::node::CmdHeader* add_replys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::CmdHeader >&
      replys() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.node.NodeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::CmdHeader > replys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class NodesInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.NodesInfo) */ {
 public:
  inline NodesInfo() : NodesInfo(nullptr) {}
  virtual ~NodesInfo();
  explicit constexpr NodesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodesInfo(const NodesInfo& from);
  NodesInfo(NodesInfo&& from) noexcept
    : NodesInfo() {
    *this = ::std::move(from);
  }

  inline NodesInfo& operator=(const NodesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodesInfo& operator=(NodesInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodesInfo* internal_default_instance() {
    return reinterpret_cast<const NodesInfo*>(
               &_NodesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(NodesInfo& a, NodesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodesInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodesInfo* New() const final {
    return CreateMaybeMessage<NodesInfo>(nullptr);
  }

  NodesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodesInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodesInfo& from);
  void MergeFrom(const NodesInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodesInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.NodesInfo";
  }
  protected:
  explicit NodesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeInfoFieldNumber = 1,
  };
  // repeated .zb.dcts.node.NodeInfo node_info = 1;
  int node_info_size() const;
  private:
  int _internal_node_info_size() const;
  public:
  void clear_node_info();
  ::zb::dcts::node::NodeInfo* mutable_node_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeInfo >*
      mutable_node_info();
  private:
  const ::zb::dcts::node::NodeInfo& _internal_node_info(int index) const;
  ::zb::dcts::node::NodeInfo* _internal_add_node_info();
  public:
  const ::zb::dcts::node::NodeInfo& node_info(int index) const;
  ::zb::dcts::node::NodeInfo* add_node_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeInfo >&
      node_info() const;

  // @@protoc_insertion_point(class_scope:zb.dcts.node.NodesInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeInfo > node_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// -------------------------------------------------------------------

class TaskAccount PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zb.dcts.node.TaskAccount) */ {
 public:
  inline TaskAccount() : TaskAccount(nullptr) {}
  virtual ~TaskAccount();
  explicit constexpr TaskAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskAccount(const TaskAccount& from);
  TaskAccount(TaskAccount&& from) noexcept
    : TaskAccount() {
    *this = ::std::move(from);
  }

  inline TaskAccount& operator=(const TaskAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskAccount& operator=(TaskAccount&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskAccount* internal_default_instance() {
    return reinterpret_cast<const TaskAccount*>(
               &_TaskAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TaskAccount& a, TaskAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskAccount* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskAccount* New() const final {
    return CreateMaybeMessage<TaskAccount>(nullptr);
  }

  TaskAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskAccount& from);
  void MergeFrom(const TaskAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zb.dcts.node.TaskAccount";
  }
  protected:
  explicit TaskAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_node_2fnode_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeDevicesFieldNumber = 2,
    kTaskIdFieldNumber = 1,
    kReplyDetailsFieldNumber = 3,
  };
  // repeated .zb.dcts.node.NodeDevice node_devices = 2;
  int node_devices_size() const;
  private:
  int _internal_node_devices_size() const;
  public:
  void clear_node_devices();
  ::zb::dcts::node::NodeDevice* mutable_node_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeDevice >*
      mutable_node_devices();
  private:
  const ::zb::dcts::node::NodeDevice& _internal_node_devices(int index) const;
  ::zb::dcts::node::NodeDevice* _internal_add_node_devices();
  public:
  const ::zb::dcts::node::NodeDevice& node_devices(int index) const;
  ::zb::dcts::node::NodeDevice* add_node_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeDevice >&
      node_devices() const;

  // .zb.dcts.TaskId task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  const ::zb::dcts::TaskId& task_id() const;
  ::zb::dcts::TaskId* release_task_id();
  ::zb::dcts::TaskId* mutable_task_id();
  void set_allocated_task_id(::zb::dcts::TaskId* task_id);
  private:
  const ::zb::dcts::TaskId& _internal_task_id() const;
  ::zb::dcts::TaskId* _internal_mutable_task_id();
  public:
  void unsafe_arena_set_allocated_task_id(
      ::zb::dcts::TaskId* task_id);
  ::zb::dcts::TaskId* unsafe_arena_release_task_id();

  // .zb.dcts.node.NodeReply reply_details = 3;
  bool has_reply_details() const;
  private:
  bool _internal_has_reply_details() const;
  public:
  void clear_reply_details();
  const ::zb::dcts::node::NodeReply& reply_details() const;
  ::zb::dcts::node::NodeReply* release_reply_details();
  ::zb::dcts::node::NodeReply* mutable_reply_details();
  void set_allocated_reply_details(::zb::dcts::node::NodeReply* reply_details);
  private:
  const ::zb::dcts::node::NodeReply& _internal_reply_details() const;
  ::zb::dcts::node::NodeReply* _internal_mutable_reply_details();
  public:
  void unsafe_arena_set_allocated_reply_details(
      ::zb::dcts::node::NodeReply* reply_details);
  ::zb::dcts::node::NodeReply* unsafe_arena_release_reply_details();

  // @@protoc_insertion_point(class_scope:zb.dcts.node.TaskAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeDevice > node_devices_;
  ::zb::dcts::TaskId* task_id_;
  ::zb::dcts::node::NodeReply* reply_details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fnode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeId

// uint32 value = 1;
inline void NodeId::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeId::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NodeId::value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeId.value)
  return _internal_value();
}
inline void NodeId::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void NodeId::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.NodeId.value)
}

// -------------------------------------------------------------------

// DeviceId

// uint32 value = 1;
inline void DeviceId::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceId::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceId::value() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceId.value)
  return _internal_value();
}
inline void DeviceId::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void DeviceId::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.DeviceId.value)
}

// -------------------------------------------------------------------

// NodeDevice

// .zb.dcts.node.NodeId node_id = 1;
inline bool NodeDevice::_internal_has_node_id() const {
  return this != internal_default_instance() && node_id_ != nullptr;
}
inline bool NodeDevice::has_node_id() const {
  return _internal_has_node_id();
}
inline void NodeDevice::clear_node_id() {
  if (GetArena() == nullptr && node_id_ != nullptr) {
    delete node_id_;
  }
  node_id_ = nullptr;
}
inline const ::zb::dcts::node::NodeId& NodeDevice::_internal_node_id() const {
  const ::zb::dcts::node::NodeId* p = node_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::NodeId&>(
      ::zb::dcts::node::_NodeId_default_instance_);
}
inline const ::zb::dcts::node::NodeId& NodeDevice::node_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeDevice.node_id)
  return _internal_node_id();
}
inline void NodeDevice::unsafe_arena_set_allocated_node_id(
    ::zb::dcts::node::NodeId* node_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  node_id_ = node_id;
  if (node_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.NodeDevice.node_id)
}
inline ::zb::dcts::node::NodeId* NodeDevice::release_node_id() {
  
  ::zb::dcts::node::NodeId* temp = node_id_;
  node_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::NodeId* NodeDevice::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeDevice.node_id)
  
  ::zb::dcts::node::NodeId* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::NodeId* NodeDevice::_internal_mutable_node_id() {
  
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::NodeId>(GetArena());
    node_id_ = p;
  }
  return node_id_;
}
inline ::zb::dcts::node::NodeId* NodeDevice::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeDevice.node_id)
  return _internal_mutable_node_id();
}
inline void NodeDevice::set_allocated_node_id(::zb::dcts::node::NodeId* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete node_id_;
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(node_id);
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeDevice.node_id)
}

// .zb.dcts.node.DeviceId device_id = 2;
inline bool NodeDevice::_internal_has_device_id() const {
  return this != internal_default_instance() && device_id_ != nullptr;
}
inline bool NodeDevice::has_device_id() const {
  return _internal_has_device_id();
}
inline void NodeDevice::clear_device_id() {
  if (GetArena() == nullptr && device_id_ != nullptr) {
    delete device_id_;
  }
  device_id_ = nullptr;
}
inline const ::zb::dcts::node::DeviceId& NodeDevice::_internal_device_id() const {
  const ::zb::dcts::node::DeviceId* p = device_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::DeviceId&>(
      ::zb::dcts::node::_DeviceId_default_instance_);
}
inline const ::zb::dcts::node::DeviceId& NodeDevice::device_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeDevice.device_id)
  return _internal_device_id();
}
inline void NodeDevice::unsafe_arena_set_allocated_device_id(
    ::zb::dcts::node::DeviceId* device_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_id_);
  }
  device_id_ = device_id;
  if (device_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.NodeDevice.device_id)
}
inline ::zb::dcts::node::DeviceId* NodeDevice::release_device_id() {
  
  ::zb::dcts::node::DeviceId* temp = device_id_;
  device_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::DeviceId* NodeDevice::unsafe_arena_release_device_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeDevice.device_id)
  
  ::zb::dcts::node::DeviceId* temp = device_id_;
  device_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::DeviceId* NodeDevice::_internal_mutable_device_id() {
  
  if (device_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::DeviceId>(GetArena());
    device_id_ = p;
  }
  return device_id_;
}
inline ::zb::dcts::node::DeviceId* NodeDevice::mutable_device_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeDevice.device_id)
  return _internal_mutable_device_id();
}
inline void NodeDevice::set_allocated_device_id(::zb::dcts::node::DeviceId* device_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete device_id_;
  }
  if (device_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(device_id);
    if (message_arena != submessage_arena) {
      device_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_id, submessage_arena);
    }
    
  } else {
    
  }
  device_id_ = device_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeDevice.device_id)
}

// -------------------------------------------------------------------

// TaskType

// .zb.dcts.node.PrimaryTaskType pri_task_type = 1;
inline void TaskType::clear_pri_task_type() {
  pri_task_type_ = 0;
}
inline ::zb::dcts::node::PrimaryTaskType TaskType::_internal_pri_task_type() const {
  return static_cast< ::zb::dcts::node::PrimaryTaskType >(pri_task_type_);
}
inline ::zb::dcts::node::PrimaryTaskType TaskType::pri_task_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskType.pri_task_type)
  return _internal_pri_task_type();
}
inline void TaskType::_internal_set_pri_task_type(::zb::dcts::node::PrimaryTaskType value) {
  
  pri_task_type_ = value;
}
inline void TaskType::set_pri_task_type(::zb::dcts::node::PrimaryTaskType value) {
  _internal_set_pri_task_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TaskType.pri_task_type)
}

// .zb.dcts.node.SecondaryTaskType sec_task_type = 2;
inline void TaskType::clear_sec_task_type() {
  sec_task_type_ = 0;
}
inline ::zb::dcts::node::SecondaryTaskType TaskType::_internal_sec_task_type() const {
  return static_cast< ::zb::dcts::node::SecondaryTaskType >(sec_task_type_);
}
inline ::zb::dcts::node::SecondaryTaskType TaskType::sec_task_type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskType.sec_task_type)
  return _internal_sec_task_type();
}
inline void TaskType::_internal_set_sec_task_type(::zb::dcts::node::SecondaryTaskType value) {
  
  sec_task_type_ = value;
}
inline void TaskType::set_sec_task_type(::zb::dcts::node::SecondaryTaskType value) {
  _internal_set_sec_task_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TaskType.sec_task_type)
}

// -------------------------------------------------------------------

// TaskSummary

// .zb.dcts.TaskId id = 1;
inline bool TaskSummary::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool TaskSummary::has_id() const {
  return _internal_has_id();
}
inline const ::zb::dcts::TaskId& TaskSummary::_internal_id() const {
  const ::zb::dcts::TaskId* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TaskId&>(
      ::zb::dcts::_TaskId_default_instance_);
}
inline const ::zb::dcts::TaskId& TaskSummary::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskSummary.id)
  return _internal_id();
}
inline void TaskSummary::unsafe_arena_set_allocated_id(
    ::zb::dcts::TaskId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskSummary.id)
}
inline ::zb::dcts::TaskId* TaskSummary::release_id() {
  
  ::zb::dcts::TaskId* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TaskId* TaskSummary::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskSummary.id)
  
  ::zb::dcts::TaskId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::TaskId* TaskSummary::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TaskId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::TaskId* TaskSummary::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskSummary.id)
  return _internal_mutable_id();
}
inline void TaskSummary::set_allocated_id(::zb::dcts::TaskId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskSummary.id)
}

// .zb.dcts.node.TaskType type = 2;
inline bool TaskSummary::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool TaskSummary::has_type() const {
  return _internal_has_type();
}
inline void TaskSummary::clear_type() {
  if (GetArena() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::zb::dcts::node::TaskType& TaskSummary::_internal_type() const {
  const ::zb::dcts::node::TaskType* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::TaskType&>(
      ::zb::dcts::node::_TaskType_default_instance_);
}
inline const ::zb::dcts::node::TaskType& TaskSummary::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskSummary.type)
  return _internal_type();
}
inline void TaskSummary::unsafe_arena_set_allocated_type(
    ::zb::dcts::node::TaskType* type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskSummary.type)
}
inline ::zb::dcts::node::TaskType* TaskSummary::release_type() {
  
  ::zb::dcts::node::TaskType* temp = type_;
  type_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::TaskType* TaskSummary::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskSummary.type)
  
  ::zb::dcts::node::TaskType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::TaskType* TaskSummary::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::TaskType>(GetArena());
    type_ = p;
  }
  return type_;
}
inline ::zb::dcts::node::TaskType* TaskSummary::mutable_type() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskSummary.type)
  return _internal_mutable_type();
}
inline void TaskSummary::set_allocated_type(::zb::dcts::node::TaskType* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskSummary.type)
}

// .zb.dcts.node.DeviceId device = 3;
inline bool TaskSummary::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool TaskSummary::has_device() const {
  return _internal_has_device();
}
inline void TaskSummary::clear_device() {
  if (GetArena() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::zb::dcts::node::DeviceId& TaskSummary::_internal_device() const {
  const ::zb::dcts::node::DeviceId* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::DeviceId&>(
      ::zb::dcts::node::_DeviceId_default_instance_);
}
inline const ::zb::dcts::node::DeviceId& TaskSummary::device() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskSummary.device)
  return _internal_device();
}
inline void TaskSummary::unsafe_arena_set_allocated_device(
    ::zb::dcts::node::DeviceId* device) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskSummary.device)
}
inline ::zb::dcts::node::DeviceId* TaskSummary::release_device() {
  
  ::zb::dcts::node::DeviceId* temp = device_;
  device_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::DeviceId* TaskSummary::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskSummary.device)
  
  ::zb::dcts::node::DeviceId* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::DeviceId* TaskSummary::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::DeviceId>(GetArena());
    device_ = p;
  }
  return device_;
}
inline ::zb::dcts::node::DeviceId* TaskSummary::mutable_device() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskSummary.device)
  return _internal_mutable_device();
}
inline void TaskSummary::set_allocated_device(::zb::dcts::node::DeviceId* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskSummary.device)
}

// .zb.dcts.node.TaskStatus status = 4;
inline void TaskSummary::clear_status() {
  status_ = 0;
}
inline ::zb::dcts::node::TaskStatus TaskSummary::_internal_status() const {
  return static_cast< ::zb::dcts::node::TaskStatus >(status_);
}
inline ::zb::dcts::node::TaskStatus TaskSummary::status() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskSummary.status)
  return _internal_status();
}
inline void TaskSummary::_internal_set_status(::zb::dcts::node::TaskStatus value) {
  
  status_ = value;
}
inline void TaskSummary::set_status(::zb::dcts::node::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TaskSummary.status)
}

// .zb.dcts.Timestamp startTime = 5;
inline bool TaskSummary::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool TaskSummary::has_starttime() const {
  return _internal_has_starttime();
}
inline const ::zb::dcts::Timestamp& TaskSummary::_internal_starttime() const {
  const ::zb::dcts::Timestamp* p = starttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Timestamp&>(
      ::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& TaskSummary::starttime() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskSummary.startTime)
  return _internal_starttime();
}
inline void TaskSummary::unsafe_arena_set_allocated_starttime(
    ::zb::dcts::Timestamp* starttime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskSummary.startTime)
}
inline ::zb::dcts::Timestamp* TaskSummary::release_starttime() {
  
  ::zb::dcts::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* TaskSummary::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskSummary.startTime)
  
  ::zb::dcts::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* TaskSummary::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    starttime_ = p;
  }
  return starttime_;
}
inline ::zb::dcts::Timestamp* TaskSummary::mutable_starttime() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskSummary.startTime)
  return _internal_mutable_starttime();
}
inline void TaskSummary::set_allocated_starttime(::zb::dcts::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime)->GetArena();
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskSummary.startTime)
}

// -------------------------------------------------------------------

// DeviceInfo

// .zb.dcts.node.DeviceId id = 1;
inline bool DeviceInfo::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool DeviceInfo::has_id() const {
  return _internal_has_id();
}
inline void DeviceInfo::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::zb::dcts::node::DeviceId& DeviceInfo::_internal_id() const {
  const ::zb::dcts::node::DeviceId* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::DeviceId&>(
      ::zb::dcts::node::_DeviceId_default_instance_);
}
inline const ::zb::dcts::node::DeviceId& DeviceInfo::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.id)
  return _internal_id();
}
inline void DeviceInfo::unsafe_arena_set_allocated_id(
    ::zb::dcts::node::DeviceId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.DeviceInfo.id)
}
inline ::zb::dcts::node::DeviceId* DeviceInfo::release_id() {
  
  ::zb::dcts::node::DeviceId* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::DeviceId* DeviceInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.DeviceInfo.id)
  
  ::zb::dcts::node::DeviceId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::DeviceId* DeviceInfo::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::DeviceId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::node::DeviceId* DeviceInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.DeviceInfo.id)
  return _internal_mutable_id();
}
inline void DeviceInfo::set_allocated_id(::zb::dcts::node::DeviceId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.DeviceInfo.id)
}

// .zb.dcts.node.DeviceType type = 2;
inline void DeviceInfo::clear_type() {
  type_ = 0;
}
inline ::zb::dcts::node::DeviceType DeviceInfo::_internal_type() const {
  return static_cast< ::zb::dcts::node::DeviceType >(type_);
}
inline ::zb::dcts::node::DeviceType DeviceInfo::type() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.type)
  return _internal_type();
}
inline void DeviceInfo::_internal_set_type(::zb::dcts::node::DeviceType value) {
  
  type_ = value;
}
inline void DeviceInfo::set_type(::zb::dcts::node::DeviceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.DeviceInfo.type)
}

// .zb.dcts.node.DeviceStatus status = 3;
inline void DeviceInfo::clear_status() {
  status_ = 0;
}
inline ::zb::dcts::node::DeviceStatus DeviceInfo::_internal_status() const {
  return static_cast< ::zb::dcts::node::DeviceStatus >(status_);
}
inline ::zb::dcts::node::DeviceStatus DeviceInfo::status() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.status)
  return _internal_status();
}
inline void DeviceInfo::_internal_set_status(::zb::dcts::node::DeviceStatus value) {
  
  status_ = value;
}
inline void DeviceInfo::set_status(::zb::dcts::node::DeviceStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.DeviceInfo.status)
}

// .zb.dcts.Position position = 4;
inline bool DeviceInfo::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool DeviceInfo::has_position() const {
  return _internal_has_position();
}
inline const ::zb::dcts::Position& DeviceInfo::_internal_position() const {
  const ::zb::dcts::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Position&>(
      ::zb::dcts::_Position_default_instance_);
}
inline const ::zb::dcts::Position& DeviceInfo::position() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.position)
  return _internal_position();
}
inline void DeviceInfo::unsafe_arena_set_allocated_position(
    ::zb::dcts::Position* position) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.DeviceInfo.position)
}
inline ::zb::dcts::Position* DeviceInfo::release_position() {
  
  ::zb::dcts::Position* temp = position_;
  position_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Position* DeviceInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.DeviceInfo.position)
  
  ::zb::dcts::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::zb::dcts::Position* DeviceInfo::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Position>(GetArena());
    position_ = p;
  }
  return position_;
}
inline ::zb::dcts::Position* DeviceInfo::mutable_position() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.DeviceInfo.position)
  return _internal_mutable_position();
}
inline void DeviceInfo::set_allocated_position(::zb::dcts::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position)->GetArena();
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.DeviceInfo.position)
}

// .zb.dcts.Posture posture = 5;
inline bool DeviceInfo::_internal_has_posture() const {
  return this != internal_default_instance() && posture_ != nullptr;
}
inline bool DeviceInfo::has_posture() const {
  return _internal_has_posture();
}
inline const ::zb::dcts::Posture& DeviceInfo::_internal_posture() const {
  const ::zb::dcts::Posture* p = posture_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Posture&>(
      ::zb::dcts::_Posture_default_instance_);
}
inline const ::zb::dcts::Posture& DeviceInfo::posture() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.posture)
  return _internal_posture();
}
inline void DeviceInfo::unsafe_arena_set_allocated_posture(
    ::zb::dcts::Posture* posture) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posture_);
  }
  posture_ = posture;
  if (posture) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.DeviceInfo.posture)
}
inline ::zb::dcts::Posture* DeviceInfo::release_posture() {
  
  ::zb::dcts::Posture* temp = posture_;
  posture_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Posture* DeviceInfo::unsafe_arena_release_posture() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.DeviceInfo.posture)
  
  ::zb::dcts::Posture* temp = posture_;
  posture_ = nullptr;
  return temp;
}
inline ::zb::dcts::Posture* DeviceInfo::_internal_mutable_posture() {
  
  if (posture_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Posture>(GetArena());
    posture_ = p;
  }
  return posture_;
}
inline ::zb::dcts::Posture* DeviceInfo::mutable_posture() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.DeviceInfo.posture)
  return _internal_mutable_posture();
}
inline void DeviceInfo::set_allocated_posture(::zb::dcts::Posture* posture) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(posture_);
  }
  if (posture) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posture)->GetArena();
    if (message_arena != submessage_arena) {
      posture = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posture, submessage_arena);
    }
    
  } else {
    
  }
  posture_ = posture;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.DeviceInfo.posture)
}

// repeated .zb.dcts.Physical physicals = 6;
inline int DeviceInfo::_internal_physicals_size() const {
  return physicals_.size();
}
inline int DeviceInfo::physicals_size() const {
  return _internal_physicals_size();
}
inline ::zb::dcts::Physical* DeviceInfo::mutable_physicals(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.DeviceInfo.physicals)
  return physicals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Physical >*
DeviceInfo::mutable_physicals() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.DeviceInfo.physicals)
  return &physicals_;
}
inline const ::zb::dcts::Physical& DeviceInfo::_internal_physicals(int index) const {
  return physicals_.Get(index);
}
inline const ::zb::dcts::Physical& DeviceInfo::physicals(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.DeviceInfo.physicals)
  return _internal_physicals(index);
}
inline ::zb::dcts::Physical* DeviceInfo::_internal_add_physicals() {
  return physicals_.Add();
}
inline ::zb::dcts::Physical* DeviceInfo::add_physicals() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.DeviceInfo.physicals)
  return _internal_add_physicals();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::Physical >&
DeviceInfo::physicals() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.DeviceInfo.physicals)
  return physicals_;
}

// -------------------------------------------------------------------

// TransferStatus

// uint32 send_fail_times = 1;
inline void TransferStatus::clear_send_fail_times() {
  send_fail_times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::_internal_send_fail_times() const {
  return send_fail_times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::send_fail_times() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TransferStatus.send_fail_times)
  return _internal_send_fail_times();
}
inline void TransferStatus::_internal_set_send_fail_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  send_fail_times_ = value;
}
inline void TransferStatus::set_send_fail_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_send_fail_times(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TransferStatus.send_fail_times)
}

// uint32 blocked_times = 2;
inline void TransferStatus::clear_blocked_times() {
  blocked_times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::_internal_blocked_times() const {
  return blocked_times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::blocked_times() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TransferStatus.blocked_times)
  return _internal_blocked_times();
}
inline void TransferStatus::_internal_set_blocked_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  blocked_times_ = value;
}
inline void TransferStatus::set_blocked_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blocked_times(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TransferStatus.blocked_times)
}

// uint32 sended_message_count = 3;
inline void TransferStatus::clear_sended_message_count() {
  sended_message_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::_internal_sended_message_count() const {
  return sended_message_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransferStatus::sended_message_count() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TransferStatus.sended_message_count)
  return _internal_sended_message_count();
}
inline void TransferStatus::_internal_set_sended_message_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sended_message_count_ = value;
}
inline void TransferStatus::set_sended_message_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sended_message_count(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.TransferStatus.sended_message_count)
}

// -------------------------------------------------------------------

// NodeInfo

// .zb.dcts.node.NodeId id = 1;
inline bool NodeInfo::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool NodeInfo::has_id() const {
  return _internal_has_id();
}
inline void NodeInfo::clear_id() {
  if (GetArena() == nullptr && id_ != nullptr) {
    delete id_;
  }
  id_ = nullptr;
}
inline const ::zb::dcts::node::NodeId& NodeInfo::_internal_id() const {
  const ::zb::dcts::node::NodeId* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::NodeId&>(
      ::zb::dcts::node::_NodeId_default_instance_);
}
inline const ::zb::dcts::node::NodeId& NodeInfo::id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.id)
  return _internal_id();
}
inline void NodeInfo::unsafe_arena_set_allocated_id(
    ::zb::dcts::node::NodeId* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.NodeInfo.id)
}
inline ::zb::dcts::node::NodeId* NodeInfo::release_id() {
  
  ::zb::dcts::node::NodeId* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::NodeId* NodeInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeInfo.id)
  
  ::zb::dcts::node::NodeId* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::NodeId* NodeInfo::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::NodeId>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::zb::dcts::node::NodeId* NodeInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.id)
  return _internal_mutable_id();
}
inline void NodeInfo::set_allocated_id(::zb::dcts::node::NodeId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeInfo.id)
}

// string name = 2;
inline void NodeInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeInfo::name() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.name)
  return _internal_name();
}
inline void NodeInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.NodeInfo.name)
}
inline std::string* NodeInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.name)
  return _internal_mutable_name();
}
inline const std::string& NodeInfo::_internal_name() const {
  return name_.Get();
}
inline void NodeInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NodeInfo::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:zb.dcts.node.NodeInfo.name)
}
inline void NodeInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:zb.dcts.node.NodeInfo.name)
}
inline void NodeInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:zb.dcts.node.NodeInfo.name)
}
inline std::string* NodeInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeInfo.name)
}

// .zb.dcts.Timestamp last_heard = 3;
inline bool NodeInfo::_internal_has_last_heard() const {
  return this != internal_default_instance() && last_heard_ != nullptr;
}
inline bool NodeInfo::has_last_heard() const {
  return _internal_has_last_heard();
}
inline const ::zb::dcts::Timestamp& NodeInfo::_internal_last_heard() const {
  const ::zb::dcts::Timestamp* p = last_heard_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::Timestamp&>(
      ::zb::dcts::_Timestamp_default_instance_);
}
inline const ::zb::dcts::Timestamp& NodeInfo::last_heard() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.last_heard)
  return _internal_last_heard();
}
inline void NodeInfo::unsafe_arena_set_allocated_last_heard(
    ::zb::dcts::Timestamp* last_heard) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heard_);
  }
  last_heard_ = last_heard;
  if (last_heard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.NodeInfo.last_heard)
}
inline ::zb::dcts::Timestamp* NodeInfo::release_last_heard() {
  
  ::zb::dcts::Timestamp* temp = last_heard_;
  last_heard_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::Timestamp* NodeInfo::unsafe_arena_release_last_heard() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeInfo.last_heard)
  
  ::zb::dcts::Timestamp* temp = last_heard_;
  last_heard_ = nullptr;
  return temp;
}
inline ::zb::dcts::Timestamp* NodeInfo::_internal_mutable_last_heard() {
  
  if (last_heard_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::Timestamp>(GetArena());
    last_heard_ = p;
  }
  return last_heard_;
}
inline ::zb::dcts::Timestamp* NodeInfo::mutable_last_heard() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.last_heard)
  return _internal_mutable_last_heard();
}
inline void NodeInfo::set_allocated_last_heard(::zb::dcts::Timestamp* last_heard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heard_);
  }
  if (last_heard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_heard)->GetArena();
    if (message_arena != submessage_arena) {
      last_heard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_heard, submessage_arena);
    }
    
  } else {
    
  }
  last_heard_ = last_heard;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeInfo.last_heard)
}

// repeated .zb.dcts.node.TaskSummary tasks = 6;
inline int NodeInfo::_internal_tasks_size() const {
  return tasks_.size();
}
inline int NodeInfo::tasks_size() const {
  return _internal_tasks_size();
}
inline void NodeInfo::clear_tasks() {
  tasks_.Clear();
}
inline ::zb::dcts::node::TaskSummary* NodeInfo::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.tasks)
  return tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::TaskSummary >*
NodeInfo::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.NodeInfo.tasks)
  return &tasks_;
}
inline const ::zb::dcts::node::TaskSummary& NodeInfo::_internal_tasks(int index) const {
  return tasks_.Get(index);
}
inline const ::zb::dcts::node::TaskSummary& NodeInfo::tasks(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.tasks)
  return _internal_tasks(index);
}
inline ::zb::dcts::node::TaskSummary* NodeInfo::_internal_add_tasks() {
  return tasks_.Add();
}
inline ::zb::dcts::node::TaskSummary* NodeInfo::add_tasks() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.NodeInfo.tasks)
  return _internal_add_tasks();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::TaskSummary >&
NodeInfo::tasks() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.NodeInfo.tasks)
  return tasks_;
}

// repeated .zb.dcts.node.DeviceInfo devices = 7;
inline int NodeInfo::_internal_devices_size() const {
  return devices_.size();
}
inline int NodeInfo::devices_size() const {
  return _internal_devices_size();
}
inline void NodeInfo::clear_devices() {
  devices_.Clear();
}
inline ::zb::dcts::node::DeviceInfo* NodeInfo::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::DeviceInfo >*
NodeInfo::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.NodeInfo.devices)
  return &devices_;
}
inline const ::zb::dcts::node::DeviceInfo& NodeInfo::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::zb::dcts::node::DeviceInfo& NodeInfo::devices(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.devices)
  return _internal_devices(index);
}
inline ::zb::dcts::node::DeviceInfo* NodeInfo::_internal_add_devices() {
  return devices_.Add();
}
inline ::zb::dcts::node::DeviceInfo* NodeInfo::add_devices() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.NodeInfo.devices)
  return _internal_add_devices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::DeviceInfo >&
NodeInfo::devices() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.NodeInfo.devices)
  return devices_;
}

// .zb.dcts.node.TransferStatus pipeline_status = 8;
inline bool NodeInfo::_internal_has_pipeline_status() const {
  return this != internal_default_instance() && pipeline_status_ != nullptr;
}
inline bool NodeInfo::has_pipeline_status() const {
  return _internal_has_pipeline_status();
}
inline void NodeInfo::clear_pipeline_status() {
  if (GetArena() == nullptr && pipeline_status_ != nullptr) {
    delete pipeline_status_;
  }
  pipeline_status_ = nullptr;
}
inline const ::zb::dcts::node::TransferStatus& NodeInfo::_internal_pipeline_status() const {
  const ::zb::dcts::node::TransferStatus* p = pipeline_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::TransferStatus&>(
      ::zb::dcts::node::_TransferStatus_default_instance_);
}
inline const ::zb::dcts::node::TransferStatus& NodeInfo::pipeline_status() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeInfo.pipeline_status)
  return _internal_pipeline_status();
}
inline void NodeInfo::unsafe_arena_set_allocated_pipeline_status(
    ::zb::dcts::node::TransferStatus* pipeline_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipeline_status_);
  }
  pipeline_status_ = pipeline_status;
  if (pipeline_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.NodeInfo.pipeline_status)
}
inline ::zb::dcts::node::TransferStatus* NodeInfo::release_pipeline_status() {
  
  ::zb::dcts::node::TransferStatus* temp = pipeline_status_;
  pipeline_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::TransferStatus* NodeInfo::unsafe_arena_release_pipeline_status() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.NodeInfo.pipeline_status)
  
  ::zb::dcts::node::TransferStatus* temp = pipeline_status_;
  pipeline_status_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::TransferStatus* NodeInfo::_internal_mutable_pipeline_status() {
  
  if (pipeline_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::TransferStatus>(GetArena());
    pipeline_status_ = p;
  }
  return pipeline_status_;
}
inline ::zb::dcts::node::TransferStatus* NodeInfo::mutable_pipeline_status() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeInfo.pipeline_status)
  return _internal_mutable_pipeline_status();
}
inline void NodeInfo::set_allocated_pipeline_status(::zb::dcts::node::TransferStatus* pipeline_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pipeline_status_;
  }
  if (pipeline_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pipeline_status);
    if (message_arena != submessage_arena) {
      pipeline_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipeline_status, submessage_arena);
    }
    
  } else {
    
  }
  pipeline_status_ = pipeline_status;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.NodeInfo.pipeline_status)
}

// -------------------------------------------------------------------

// CmdHeader

// uint32 sequence_number = 1;
inline void CmdHeader::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdHeader::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CmdHeader::sequence_number() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.CmdHeader.sequence_number)
  return _internal_sequence_number();
}
inline void CmdHeader::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_number_ = value;
}
inline void CmdHeader::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.CmdHeader.sequence_number)
}

// .zb.dcts.node.ErrorType error_code = 2;
inline void CmdHeader::clear_error_code() {
  error_code_ = 0;
}
inline ::zb::dcts::node::ErrorType CmdHeader::_internal_error_code() const {
  return static_cast< ::zb::dcts::node::ErrorType >(error_code_);
}
inline ::zb::dcts::node::ErrorType CmdHeader::error_code() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.CmdHeader.error_code)
  return _internal_error_code();
}
inline void CmdHeader::_internal_set_error_code(::zb::dcts::node::ErrorType value) {
  
  error_code_ = value;
}
inline void CmdHeader::set_error_code(::zb::dcts::node::ErrorType value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:zb.dcts.node.CmdHeader.error_code)
}

// .zb.dcts.TaskId task_id = 3;
inline bool CmdHeader::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool CmdHeader::has_task_id() const {
  return _internal_has_task_id();
}
inline const ::zb::dcts::TaskId& CmdHeader::_internal_task_id() const {
  const ::zb::dcts::TaskId* p = task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TaskId&>(
      ::zb::dcts::_TaskId_default_instance_);
}
inline const ::zb::dcts::TaskId& CmdHeader::task_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.CmdHeader.task_id)
  return _internal_task_id();
}
inline void CmdHeader::unsafe_arena_set_allocated_task_id(
    ::zb::dcts::TaskId* task_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.CmdHeader.task_id)
}
inline ::zb::dcts::TaskId* CmdHeader::release_task_id() {
  
  ::zb::dcts::TaskId* temp = task_id_;
  task_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TaskId* CmdHeader::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.CmdHeader.task_id)
  
  ::zb::dcts::TaskId* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::TaskId* CmdHeader::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TaskId>(GetArena());
    task_id_ = p;
  }
  return task_id_;
}
inline ::zb::dcts::TaskId* CmdHeader::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.CmdHeader.task_id)
  return _internal_mutable_task_id();
}
inline void CmdHeader::set_allocated_task_id(::zb::dcts::TaskId* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id)->GetArena();
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.CmdHeader.task_id)
}

// .zb.dcts.node.NodeDevice task_runner = 4;
inline bool CmdHeader::_internal_has_task_runner() const {
  return this != internal_default_instance() && task_runner_ != nullptr;
}
inline bool CmdHeader::has_task_runner() const {
  return _internal_has_task_runner();
}
inline void CmdHeader::clear_task_runner() {
  if (GetArena() == nullptr && task_runner_ != nullptr) {
    delete task_runner_;
  }
  task_runner_ = nullptr;
}
inline const ::zb::dcts::node::NodeDevice& CmdHeader::_internal_task_runner() const {
  const ::zb::dcts::node::NodeDevice* p = task_runner_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::NodeDevice&>(
      ::zb::dcts::node::_NodeDevice_default_instance_);
}
inline const ::zb::dcts::node::NodeDevice& CmdHeader::task_runner() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.CmdHeader.task_runner)
  return _internal_task_runner();
}
inline void CmdHeader::unsafe_arena_set_allocated_task_runner(
    ::zb::dcts::node::NodeDevice* task_runner) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_runner_);
  }
  task_runner_ = task_runner;
  if (task_runner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.CmdHeader.task_runner)
}
inline ::zb::dcts::node::NodeDevice* CmdHeader::release_task_runner() {
  
  ::zb::dcts::node::NodeDevice* temp = task_runner_;
  task_runner_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::NodeDevice* CmdHeader::unsafe_arena_release_task_runner() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.CmdHeader.task_runner)
  
  ::zb::dcts::node::NodeDevice* temp = task_runner_;
  task_runner_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::NodeDevice* CmdHeader::_internal_mutable_task_runner() {
  
  if (task_runner_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::NodeDevice>(GetArena());
    task_runner_ = p;
  }
  return task_runner_;
}
inline ::zb::dcts::node::NodeDevice* CmdHeader::mutable_task_runner() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.CmdHeader.task_runner)
  return _internal_mutable_task_runner();
}
inline void CmdHeader::set_allocated_task_runner(::zb::dcts::node::NodeDevice* task_runner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete task_runner_;
  }
  if (task_runner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(task_runner);
    if (message_arena != submessage_arena) {
      task_runner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_runner, submessage_arena);
    }
    
  } else {
    
  }
  task_runner_ = task_runner;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.CmdHeader.task_runner)
}

// -------------------------------------------------------------------

// NodeReply

// repeated .zb.dcts.node.CmdHeader replys = 1;
inline int NodeReply::_internal_replys_size() const {
  return replys_.size();
}
inline int NodeReply::replys_size() const {
  return _internal_replys_size();
}
inline void NodeReply::clear_replys() {
  replys_.Clear();
}
inline ::zb::dcts::node::CmdHeader* NodeReply::mutable_replys(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodeReply.replys)
  return replys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::CmdHeader >*
NodeReply::mutable_replys() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.NodeReply.replys)
  return &replys_;
}
inline const ::zb::dcts::node::CmdHeader& NodeReply::_internal_replys(int index) const {
  return replys_.Get(index);
}
inline const ::zb::dcts::node::CmdHeader& NodeReply::replys(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodeReply.replys)
  return _internal_replys(index);
}
inline ::zb::dcts::node::CmdHeader* NodeReply::_internal_add_replys() {
  return replys_.Add();
}
inline ::zb::dcts::node::CmdHeader* NodeReply::add_replys() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.NodeReply.replys)
  return _internal_add_replys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::CmdHeader >&
NodeReply::replys() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.NodeReply.replys)
  return replys_;
}

// -------------------------------------------------------------------

// NodesInfo

// repeated .zb.dcts.node.NodeInfo node_info = 1;
inline int NodesInfo::_internal_node_info_size() const {
  return node_info_.size();
}
inline int NodesInfo::node_info_size() const {
  return _internal_node_info_size();
}
inline void NodesInfo::clear_node_info() {
  node_info_.Clear();
}
inline ::zb::dcts::node::NodeInfo* NodesInfo::mutable_node_info(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.NodesInfo.node_info)
  return node_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeInfo >*
NodesInfo::mutable_node_info() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.NodesInfo.node_info)
  return &node_info_;
}
inline const ::zb::dcts::node::NodeInfo& NodesInfo::_internal_node_info(int index) const {
  return node_info_.Get(index);
}
inline const ::zb::dcts::node::NodeInfo& NodesInfo::node_info(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.NodesInfo.node_info)
  return _internal_node_info(index);
}
inline ::zb::dcts::node::NodeInfo* NodesInfo::_internal_add_node_info() {
  return node_info_.Add();
}
inline ::zb::dcts::node::NodeInfo* NodesInfo::add_node_info() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.NodesInfo.node_info)
  return _internal_add_node_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeInfo >&
NodesInfo::node_info() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.NodesInfo.node_info)
  return node_info_;
}

// -------------------------------------------------------------------

// TaskAccount

// .zb.dcts.TaskId task_id = 1;
inline bool TaskAccount::_internal_has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline bool TaskAccount::has_task_id() const {
  return _internal_has_task_id();
}
inline const ::zb::dcts::TaskId& TaskAccount::_internal_task_id() const {
  const ::zb::dcts::TaskId* p = task_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::TaskId&>(
      ::zb::dcts::_TaskId_default_instance_);
}
inline const ::zb::dcts::TaskId& TaskAccount::task_id() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskAccount.task_id)
  return _internal_task_id();
}
inline void TaskAccount::unsafe_arena_set_allocated_task_id(
    ::zb::dcts::TaskId* task_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  task_id_ = task_id;
  if (task_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskAccount.task_id)
}
inline ::zb::dcts::TaskId* TaskAccount::release_task_id() {
  
  ::zb::dcts::TaskId* temp = task_id_;
  task_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::TaskId* TaskAccount::unsafe_arena_release_task_id() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskAccount.task_id)
  
  ::zb::dcts::TaskId* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::zb::dcts::TaskId* TaskAccount::_internal_mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::TaskId>(GetArena());
    task_id_ = p;
  }
  return task_id_;
}
inline ::zb::dcts::TaskId* TaskAccount::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskAccount.task_id)
  return _internal_mutable_task_id();
}
inline void TaskAccount::set_allocated_task_id(::zb::dcts::TaskId* task_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id_);
  }
  if (task_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_id)->GetArena();
    if (message_arena != submessage_arena) {
      task_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskAccount.task_id)
}

// repeated .zb.dcts.node.NodeDevice node_devices = 2;
inline int TaskAccount::_internal_node_devices_size() const {
  return node_devices_.size();
}
inline int TaskAccount::node_devices_size() const {
  return _internal_node_devices_size();
}
inline void TaskAccount::clear_node_devices() {
  node_devices_.Clear();
}
inline ::zb::dcts::node::NodeDevice* TaskAccount::mutable_node_devices(int index) {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskAccount.node_devices)
  return node_devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeDevice >*
TaskAccount::mutable_node_devices() {
  // @@protoc_insertion_point(field_mutable_list:zb.dcts.node.TaskAccount.node_devices)
  return &node_devices_;
}
inline const ::zb::dcts::node::NodeDevice& TaskAccount::_internal_node_devices(int index) const {
  return node_devices_.Get(index);
}
inline const ::zb::dcts::node::NodeDevice& TaskAccount::node_devices(int index) const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskAccount.node_devices)
  return _internal_node_devices(index);
}
inline ::zb::dcts::node::NodeDevice* TaskAccount::_internal_add_node_devices() {
  return node_devices_.Add();
}
inline ::zb::dcts::node::NodeDevice* TaskAccount::add_node_devices() {
  // @@protoc_insertion_point(field_add:zb.dcts.node.TaskAccount.node_devices)
  return _internal_add_node_devices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zb::dcts::node::NodeDevice >&
TaskAccount::node_devices() const {
  // @@protoc_insertion_point(field_list:zb.dcts.node.TaskAccount.node_devices)
  return node_devices_;
}

// .zb.dcts.node.NodeReply reply_details = 3;
inline bool TaskAccount::_internal_has_reply_details() const {
  return this != internal_default_instance() && reply_details_ != nullptr;
}
inline bool TaskAccount::has_reply_details() const {
  return _internal_has_reply_details();
}
inline void TaskAccount::clear_reply_details() {
  if (GetArena() == nullptr && reply_details_ != nullptr) {
    delete reply_details_;
  }
  reply_details_ = nullptr;
}
inline const ::zb::dcts::node::NodeReply& TaskAccount::_internal_reply_details() const {
  const ::zb::dcts::node::NodeReply* p = reply_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::zb::dcts::node::NodeReply&>(
      ::zb::dcts::node::_NodeReply_default_instance_);
}
inline const ::zb::dcts::node::NodeReply& TaskAccount::reply_details() const {
  // @@protoc_insertion_point(field_get:zb.dcts.node.TaskAccount.reply_details)
  return _internal_reply_details();
}
inline void TaskAccount::unsafe_arena_set_allocated_reply_details(
    ::zb::dcts::node::NodeReply* reply_details) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reply_details_);
  }
  reply_details_ = reply_details;
  if (reply_details) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zb.dcts.node.TaskAccount.reply_details)
}
inline ::zb::dcts::node::NodeReply* TaskAccount::release_reply_details() {
  
  ::zb::dcts::node::NodeReply* temp = reply_details_;
  reply_details_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::zb::dcts::node::NodeReply* TaskAccount::unsafe_arena_release_reply_details() {
  // @@protoc_insertion_point(field_release:zb.dcts.node.TaskAccount.reply_details)
  
  ::zb::dcts::node::NodeReply* temp = reply_details_;
  reply_details_ = nullptr;
  return temp;
}
inline ::zb::dcts::node::NodeReply* TaskAccount::_internal_mutable_reply_details() {
  
  if (reply_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::zb::dcts::node::NodeReply>(GetArena());
    reply_details_ = p;
  }
  return reply_details_;
}
inline ::zb::dcts::node::NodeReply* TaskAccount::mutable_reply_details() {
  // @@protoc_insertion_point(field_mutable:zb.dcts.node.TaskAccount.reply_details)
  return _internal_mutable_reply_details();
}
inline void TaskAccount::set_allocated_reply_details(::zb::dcts::node::NodeReply* reply_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reply_details_;
  }
  if (reply_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reply_details);
    if (message_arena != submessage_arena) {
      reply_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reply_details, submessage_arena);
    }
    
  } else {
    
  }
  reply_details_ = reply_details;
  // @@protoc_insertion_point(field_set_allocated:zb.dcts.node.TaskAccount.reply_details)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace node
}  // namespace dcts
}  // namespace zb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zb::dcts::node::PrimaryTaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::PrimaryTaskType>() {
  return ::zb::dcts::node::PrimaryTaskType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::SecondaryTaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::SecondaryTaskType>() {
  return ::zb::dcts::node::SecondaryTaskType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::TaskStatus>() {
  return ::zb::dcts::node::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::DeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::DeviceType>() {
  return ::zb::dcts::node::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::DeviceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::DeviceStatus>() {
  return ::zb::dcts::node::DeviceStatus_descriptor();
}
template <> struct is_proto_enum< ::zb::dcts::node::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zb::dcts::node::ErrorType>() {
  return ::zb::dcts::node::ErrorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_2fnode_2eproto
